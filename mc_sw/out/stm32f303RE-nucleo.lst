
d:/prg/prj/github/nucleo-f303re-ChibiOS-RT-template/mc_sw/out/stm32f303RE-nucleo.elf:     file format elf32-littlearm
d:/prg/prj/github/nucleo-f303re-ChibiOS-RT-template/mc_sw/out/stm32f303RE-nucleo.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080001d1

Program Header:
    LOAD off    0x00010000 vaddr 0x08000000 paddr 0x08000000 align 2**16
         filesz 0x00001b18 memsz 0x00001b18 flags rwx
    LOAD off    0x00020800 vaddr 0x20000800 paddr 0x08001b18 align 2**16
         filesz 0x00000024 memsz 0x00000024 flags rw-
    LOAD off    0x00020828 vaddr 0x20000828 paddr 0x08001b3c align 2**16
         filesz 0x00000000 memsz 0x00000678 flags rw-
    LOAD off    0x00030000 vaddr 0x20000000 paddr 0x20000000 align 2**16
         filesz 0x00000000 memsz 0x00010000 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mstack       00000400  20000000  20000000  00030000  2**0
                  ALLOC
  1 .pstack       00000400  20000400  20000400  00030000  2**0
                  ALLOC
  2 vectors       000001a0  08000000  08000000  00010000  2**7
                  CONTENTS, ALLOC, LOAD, DATA
  3 .text         000017dc  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000019c  0800197c  0800197c  0001197c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000024  20000800  08001b18  00020800  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000678  20000828  08001b3c  00020828  2**3
                  ALLOC
  7 .ram0_init    00000000  20000ea0  20000ea0  00020824  2**2
                  CONTENTS
  8 .ram0         00000000  20000ea0  20000ea0  00020824  2**2
                  CONTENTS
  9 .ram1_init    00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 10 .ram1         00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 11 .ram2_init    00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 12 .ram2         00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 13 .ram3_init    00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 14 .ram3         00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 15 .ram4_init    00000000  10000000  10000000  00020824  2**2
                  CONTENTS
 16 .ram4         00000000  10000000  10000000  00020824  2**2
                  CONTENTS
 17 .ram5_init    00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 18 .ram5         00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 19 .ram6_init    00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 20 .ram6         00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 21 .ram7_init    00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 22 .ram7         00000000  00000000  00000000  00020824  2**2
                  CONTENTS
 23 .heap         0000f160  20000ea0  20000ea0  00030000  2**0
                  ALLOC
 24 .debug_info   000069d6  00000000  00000000  00020824  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_abbrev 00000c5c  00000000  00000000  000271fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_loc    00002210  00000000  00000000  00027e56  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_aranges 00000240  00000000  00000000  0002a068  2**3
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_ranges 00000f58  00000000  00000000  0002a2a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_line   00002338  00000000  00000000  0002b200  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_str    000016c7  00000000  00000000  0002d538  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .comment      0000006e  00000000  00000000  0002ebff  2**0
                  CONTENTS, READONLY
 32 .ARM.attributes 00000037  00000000  00000000  0002ec6d  2**0
                  CONTENTS, READONLY
 33 .debug_frame  00000684  00000000  00000000  0002eca4  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
20000000 l    d  .mstack	00000000 .mstack
20000400 l    d  .pstack	00000000 .pstack
08000000 l    d  vectors	00000000 vectors
080001a0 l    d  .text	00000000 .text
0800197c l    d  .rodata	00000000 .rodata
20000800 l    d  .data	00000000 .data
20000828 l    d  .bss	00000000 .bss
20000ea0 l    d  .ram0_init	00000000 .ram0_init
20000ea0 l    d  .ram0	00000000 .ram0
00000000 l    d  .ram1_init	00000000 .ram1_init
00000000 l    d  .ram1	00000000 .ram1
00000000 l    d  .ram2_init	00000000 .ram2_init
00000000 l    d  .ram2	00000000 .ram2
00000000 l    d  .ram3_init	00000000 .ram3_init
00000000 l    d  .ram3	00000000 .ram3
10000000 l    d  .ram4_init	00000000 .ram4_init
10000000 l    d  .ram4	00000000 .ram4
00000000 l    d  .ram5_init	00000000 .ram5_init
00000000 l    d  .ram5	00000000 .ram5
00000000 l    d  .ram6_init	00000000 .ram6_init
00000000 l    d  .ram6	00000000 .ram6
00000000 l    d  .ram7_init	00000000 .ram7_init
00000000 l    d  .ram7	00000000 .ram7
20000ea0 l    d  .heap	00000000 .heap
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 
080002e0 l     F .text	0000000c chTMStartMeasurementX.constprop.30
080002f0 l     F .text	000000a0 _pal_lld_setgroupmode.constprop.19
08000390 l     F .text	000000b4 dmaStreamAllocate.constprop.9
08000450 l     F .text	00000002 _unhandled_exception
08000450 l     F .text	00000002 Vector48
08000450 l     F .text	00000002 Vector4C
08000450 l     F .text	00000002 Vector50
08000450 l     F .text	00000002 Vector54
08000450 l     F .text	00000002 Vector58
08000450 l     F .text	00000002 Vector5C
08000450 l     F .text	00000002 Vector60
08000450 l     F .text	00000002 Vector64
08000450 l     F .text	00000002 Vector68
08000450 l     F .text	00000002 Vector34
08000450 l     F .text	00000002 DebugMon_Handler
08000450 l     F .text	00000002 Vector44
08000450 l     F .text	00000002 Vector28
08000450 l     F .text	00000002 Vector24
08000450 l     F .text	00000002 Vector20
08000450 l     F .text	00000002 Vector1C
08000450 l     F .text	00000002 Vector88
08000450 l     F .text	00000002 Vector8C
08000450 l     F .text	00000002 Vector90
08000450 l     F .text	00000002 Vector94
08000450 l     F .text	00000002 Vector98
08000450 l     F .text	00000002 Vector9C
08000450 l     F .text	00000002 VectorA0
08000450 l     F .text	00000002 VectorA4
08000450 l     F .text	00000002 VectorA8
08000450 l     F .text	00000002 VectorAC
08000450 l     F .text	00000002 VectorB0
08000450 l     F .text	00000002 VectorB4
08000450 l     F .text	00000002 VectorB8
08000450 l     F .text	00000002 VectorBC
08000450 l     F .text	00000002 VectorC0
08000450 l     F .text	00000002 VectorC4
08000450 l     F .text	00000002 VectorC8
08000450 l     F .text	00000002 VectorCC
08000450 l     F .text	00000002 VectorD0
08000450 l     F .text	00000002 VectorD4
08000450 l     F .text	00000002 Vector40
08000450 l     F .text	00000002 PendSV_Handler
08000450 l     F .text	00000002 VectorE0
08000450 l     F .text	00000002 VectorE4
08000450 l     F .text	00000002 VectorE8
08000450 l     F .text	00000002 VectorEC
08000450 l     F .text	00000002 VectorF0
08000450 l     F .text	00000002 VectorF4
08000450 l     F .text	00000002 VectorF8
08000450 l     F .text	00000002 VectorFC
08000450 l     F .text	00000002 Vector100
08000450 l     F .text	00000002 Vector104
08000450 l     F .text	00000002 Vector108
08000450 l     F .text	00000002 Vector10C
08000450 l     F .text	00000002 Vector110
08000450 l     F .text	00000002 Vector114
08000450 l     F .text	00000002 Vector118
08000450 l     F .text	00000002 Vector11C
08000450 l     F .text	00000002 UsageFault_Handler
08000450 l     F .text	00000002 BusFault_Handler
08000450 l     F .text	00000002 MemManage_Handler
08000450 l     F .text	00000002 HardFault_Handler
08000450 l     F .text	00000002 NMI_Handler
08000450 l     F .text	00000002 Vector134
08000450 l     F .text	00000002 Vector138
08000450 l     F .text	00000002 Vector13C
08000450 l     F .text	00000002 Vector140
08000450 l     F .text	00000002 Vector144
08000450 l     F .text	00000002 Vector148
08000450 l     F .text	00000002 Vector14C
08000450 l     F .text	00000002 Vector150
08000450 l     F .text	00000002 Vector154
08000450 l     F .text	00000002 Vector158
08000450 l     F .text	00000002 Vector15C
08000450 l     F .text	00000002 Vector160
08000450 l     F .text	00000002 Vector164
08000450 l     F .text	00000002 Vector168
08000450 l     F .text	00000002 Vector16C
08000450 l     F .text	00000002 Vector170
08000450 l     F .text	00000002 Vector174
08000450 l     F .text	00000002 Vector178
08000450 l     F .text	00000002 Vector17C
08000450 l     F .text	00000002 Vector180
08000450 l     F .text	00000002 Vector184
08000450 l     F .text	00000002 Vector188
08000450 l     F .text	00000002 Vector18C
08000450 l     F .text	00000002 Vector190
08000450 l     F .text	00000002 Vector194
08000450 l     F .text	00000002 Vector198
08000450 l     F .text	00000002 Vector19C
08000460 l     F .text	00000002 rxend
08000470 l     F .text	00000058 chSchWakeupS.constprop.33
080004d0 l     F .text	00000068 chThdCreateStatic.constprop.28
08000540 l     F .text	00000030 Vector130
08000570 l     F .text	00000030 Vector12C
080005a0 l     F .text	00000030 Vector128
080005d0 l     F .text	00000030 Vector124
08000600 l     F .text	00000028 Vector120
08000630 l     F .text	00000030 Vector84
08000660 l     F .text	00000030 Vector80
08000690 l     F .text	00000030 Vector7C
080006c0 l     F .text	00000030 Vector78
080006f0 l     F .text	00000030 Vector74
08000720 l     F .text	00000030 Vector70
08000750 l     F .text	00000028 Vector6C
08000780 l     F .text	00000030 Task_50ms
080007b0 l     F .text	00000018 Task_5ms
080007d0 l     F .text	00000048 rxchar
20000828 l     O .bss	00000060 _stm32_dma_isr_redir
20000960 l     O .bss	00000001 rbi_LedStatus
20000968 l     O .bss	000001c0 pool_Task_5ms
20000800 l     O .data	00000024 uartcfg
20000b28 l     O .bss	00000040 buffer
0800197c l     O .rodata	000000f0 _stm32_dma_streams
20000b68 l     O .bss	000001c0 pool_Task_50ms
20000d48 l     O .bss	00000150 ch_idle_thread_wa
08001a6c l     O .rodata	00000020 vmt
20000e98 l     O .bss	00000001 rub_LedTimeout
20000e9c l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 d:/prg/prj/github/nucleo-f303re-ChibiOS-RT-template/mc_sw/obj/chcoreasm_v7m.o
e000ed04 l       *ABS*	00000000 SCB_ICSR
10000000 l       *ABS*	00000000 ICSR_PENDSVSET
00000000 l    df *ABS*	00000000 d:/prg/prj/github/nucleo-f303re-ChibiOS-RT-template/mc_sw/obj/crt0_v7m.o
08000238 l       .text	00000000 msloop
08000246 l       .text	00000000 psloop
08000256 l       .text	00000000 dloop
0800026a l       .text	00000000 bloop
08000280 l       .text	00000000 initloop
0800028c l       .text	00000000 endinitloop
08000294 l       .text	00000000 finiloop
080002a0 l       .text	00000000 endfiniloop
00000000 l    df *ABS*	00000000 
08001060 l     F .text	00000070 wakeup
080010f0 l     F .text	00000024 chSchGoSleepS
080012d0 l     F .text	00000028 chThdEnqueueTimeoutS
080013d0 l     F .text	00000052 oqPutTimeout
08001450 l     F .text	000000a8 iqReadTimeout
08001520 l     F .text	00000052 iqGetTimeout
08001a98 l     O .rodata	00000080 ram_areas
00000000 l    df *ABS*	00000000 
20000ea0 l       .heap	00000000 __heap_base__
20010000 l       .heap	00000000 __heap_end__
080013b0 g     F .text	00000006 .hidden writet.lto_priv.49
080015d0 g     F .text	00000038 chThdExit
08001250 g     F .text	00000080 .hidden chSchGoSleepTimeoutS
10000000 g       .rodata	00000000 __ram4_start__
00000000 g       .ram5	00000000 __ram5_clear__
20000ea0 g       .ram0_init	00000000 __ram0_init__
080016f0 g     F .text	00000058 .hidden SysTick_Handler
00000000 g       .ram1	00000000 __ram1_free__
08001680 g     F .text	0000006c .hidden VectorDC
00000000 g       .rodata	00000000 __ram6_start__
08000000 g     O vectors	000001a0 _vectors
08001b18 g       .data	00000000 __exidx_end
20000ea0 g       .ram0	00000000 __ram0_free__
08001b3c g       *ABS*	00000000 __ram3_init_text__
00000000 g       *ABS*	00000000 __ram5_end__
00000000 g       .ram5	00000000 __ram5_noinit__
00000000 g       *ABS*	00000000 __ram5_size__
20000888 g     O .bss	0000007c .hidden SD2
080015a0 g     F .text	0000002c .hidden chSchReadyI
080011c0 g     F .text	00000044 .hidden chTMStopMeasurementX
080001a0 g       vectors	00000000 __fini_array_end
20000800 g       .pstack	00000000 __main_thread_stack_end__
08001b18 g       .rodata	00000000 __rodata_end__
20000828 g       .bss	00000000 _bss_start
08000fb0 g     F .text	00000088 .hidden uart_lld_serve_rx_end_irq.lto_priv.36
00000000 g       *ABS*	00000000 __ram1_size__
00000000 g       .ram1	00000000 __ram1_clear__
00000000 g       .ram7	00000000 __ram7_free__
00004000 g       *ABS*	00000000 __ram4_size__
00000000 g       *ABS*	00000000 __ram1_end__
10004000 g       *ABS*	00000000 __ram4_end__
08001b18 g       .data	00000000 __exidx_start
08001b3c g       *ABS*	00000000 __ram0_init_text__
08001b3c g       *ABS*	00000000 __ram1_init_text__
00010000 g       *ABS*	00000000 __ram0_size__
08001b3c g       *ABS*	00000000 __ram5_init_text__
08000f60 g     F .text	0000004c .hidden uart_lld_serve_tx_end_irq.lto_priv.37
08001430 g     F .text	00000006 .hidden putt.lto_priv.47
20000ea0 g       .bss	00000000 _bss_end
08001050 g     F .text	00000002 .hidden _idle_thread.lto_priv.42
080001d0 g     F .text	00000000 Reset_Handler
10000000 g       .ram4	00000000 __ram4_clear__
00000000 g       .ram5	00000000 __ram5_free__
08001750 g     F .text	00000190 .hidden VectorD8
08001b3c g       *ABS*	00000000 __ram6_init_text__
08000f40 g     F .text	00000002 .hidden txend1.lto_priv.39
00000000 g       .ram3	00000000 __ram3_clear__
08001190 g     F .text	00000002 __default_exit
00000000 g       *ABS*	00000000 __ram6_end__
00000000 g       .ram6_init	00000000 __ram6_init__
08001210 g     F .text	0000003c chSchDoReschedule
00000000 g       .ram7_init	00000000 __ram7_init__
00000000 g       .ram6	00000000 __ram6_free__
00000000 g       .ram2	00000000 __ram2_noinit__
00000000 g       .ram6	00000000 __ram6_noinit__
08000f30 g     F .text	00000002 .hidden rxerr.lto_priv.41
10000000 g       .ram4_init	00000000 __ram4_init__
00000000 g       .ram7	00000000 __ram7_clear__
08000820 g     F .text	00000064 .hidden chEvtBroadcastFlagsI.constprop.35
20000800 g       .data	00000000 _data_start
00000000 g       *ABS*	00000000 __ram7_size__
080001a0 g     F .text	00000000 _port_switch
080011b0 g     F .text	00000002 __core_init
10000000 g       .ram4	00000000 __ram4_noinit__
08001590 g     F .text	0000000a .hidden get.lto_priv.46
080011a0 g     F .text	00000002 __late_init
08001610 g     F .text	00000064 .hidden _port_irq_epilogue
00000000 g       .rodata	00000000 __ram7_start__
00000000 g       .ram6	00000000 __ram6_clear__
080013c0 g     F .text	0000000a .hidden write.lto_priv.43
08001300 g     F .text	000000a8 .hidden oqWriteTimeout
20000824 g       .data	00000000 _data_end
00000000 g       *ABS*	00000000 __ram3_size__
080001a0 g       vectors	00000000 __fini_array_start
00000000 g       .ram2	00000000 __ram2_clear__
00000000 g       *ABS*	00000000 __ram3_end__
00000000 g       *ABS*	00000000 __ram2_size__
00000000 g       .rodata	00000000 __ram1_start__
0800197c g       .rodata	00000000 __rodata_base__
08000890 g     F .text	00000694 main
00000000 g       *ABS*	00000000 __ram6_size__
08001b3c g       *ABS*	00000000 __ram2_init_text__
080010d0 g     F .text	00000020 .hidden SVC_Handler
00000000 g       .ram3	00000000 __ram3_free__
080001a0 g       vectors	00000000 __init_array_end
20000d28 g     O .bss	00000020 .hidden UARTD3
08001b3c g       *ABS*	00000000 __ram4_init_text__
00000000 g       .ram1	00000000 __ram1_noinit__
080001b8 g     F .text	00000000 _port_thread_start
00000000 g       .ram2_init	00000000 __ram2_init__
00000000 g       *ABS*	00000000 __ram2_end__
20000400 g       .pstack	00000000 __process_stack_base__
20000ea0 g       .ram0	00000000 __ram0_clear__
00000000 g       .ram3	00000000 __ram3_noinit__
20000ea0 g       .ram0	00000000 __ram0_noinit__
08001120 g     F .text	00000068 __init_ram_areas
00000000 g       .rodata	00000000 __ram2_start__
080001c8 g     F .text	00000000 _port_switch_from_isr
00000000 g       *ABS*	00000000 __ram7_end__
08001580 g     F .text	00000006 .hidden gett.lto_priv.48
20000400 g       .mstack	00000000 __main_stack_end__
00000000 g       .ram5_init	00000000 __ram5_init__
08001440 g     F .text	0000000a .hidden put.lto_priv.45
08001510 g     F .text	0000000a .hidden read.lto_priv.44
20000400 g       .pstack	00000000 __main_thread_stack_base__
08001b3c g       *ABS*	00000000 __ram7_init_text__
00000000 g       .ram3_init	00000000 __ram3_init__
20000000 g       .rodata	00000000 __ram0_start__
08000f50 g     F .text	00000002 .hidden txend2.lto_priv.40
080001cc g       .text	00000000 _port_exit_from_isr
00000000 g       .ram1_init	00000000 __ram1_init__
080001a0 g       vectors	00000000 __init_array_start
08001b18 g       *ABS*	00000000 _textdata_start
00000000 g       .rodata	00000000 __ram5_start__
20000904 g     O .bss	0000005c .hidden ch
00000000 g       .ram2	00000000 __ram2_free__
10000000 g       .ram4	00000000 __ram4_free__
20010000 g       *ABS*	00000000 __ram0_end__
20000000 g       .mstack	00000000 __main_stack_base__
00000400 g       *ABS*	00000000 __main_stack_size__
00000000 g       .ram7	00000000 __ram7_noinit__
08001040 g     F .text	00000010 .hidden notify2.lto_priv.38
20000800 g       .pstack	00000000 __process_stack_end__
080018e0 g     F .text	0000009c __early_init
08001500 g     F .text	00000006 .hidden readt.lto_priv.50
00000000 g       .rodata	00000000 __ram3_start__
00000400 g       *ABS*	00000000 __process_stack_size__



Disassembly of section .text:

080001a0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80001a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 80001a4:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80001a8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001ac:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001ae:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 80001b0:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80001b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080001b8 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80001b8:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80001ba:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80001be:	4628      	mov	r0, r5
                blx     r4
 80001c0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80001c2:	2000      	movs	r0, #0
                bl      chThdExit
 80001c4:	f001 fa04 	bl	80015d0 <chThdExit>

080001c8 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80001c8:	f001 f822 	bl	8001210 <chSchDoReschedule>

080001cc <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80001cc:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80001ce:	e7fe      	b.n	80001ce <_port_exit_from_isr+0x2>

080001d0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001d0:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001d2:	4834      	ldr	r0, [pc, #208]	; (80002a4 <endfiniloop+0x4>)
                msr     PSP, r0
 80001d4:	f380 8809 	msr	PSP, r0

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001d8:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001dc:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 80001e0:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 80001e4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001e8:	6008      	str	r0, [r1, #0]
                dsb
 80001ea:	f3bf 8f4f 	dsb	sy
                isb
 80001ee:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 80001f2:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 80001f6:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 80001fa:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 80001fe:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000202:	6008      	str	r0, [r1, #0]
                dsb
 8000204:	f3bf 8f4f 	dsb	sy
                isb
 8000208:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800020c:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000210:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000214:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 8000218:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800021c:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 800021e:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000220:	f380 8814 	msr	CONTROL, r0
                isb
 8000224:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000228:	f000 ffc2 	bl	80011b0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800022c:	f001 fb58 	bl	80018e0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000230:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000234:	491c      	ldr	r1, [pc, #112]	; (80002a8 <endfiniloop+0x8>)
                ldr     r2, =__main_stack_end__
 8000236:	4a1d      	ldr	r2, [pc, #116]	; (80002ac <endfiniloop+0xc>)

08000238 <msloop>:
msloop:
                cmp     r1, r2
 8000238:	4291      	cmp	r1, r2
                itt     lo
 800023a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800023c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000240:	e7fa      	bcc.n	8000238 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000242:	491b      	ldr	r1, [pc, #108]	; (80002b0 <endfiniloop+0x10>)
                ldr     r2, =__process_stack_end__
 8000244:	4a17      	ldr	r2, [pc, #92]	; (80002a4 <endfiniloop+0x4>)

08000246 <psloop>:
psloop:
                cmp     r1, r2
 8000246:	4291      	cmp	r1, r2
                itt     lo
 8000248:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800024a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800024e:	e7fa      	bcc.n	8000246 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000250:	4918      	ldr	r1, [pc, #96]	; (80002b4 <endfiniloop+0x14>)
                ldr     r2, =_data_start
 8000252:	4a19      	ldr	r2, [pc, #100]	; (80002b8 <endfiniloop+0x18>)
                ldr     r3, =_data_end
 8000254:	4b19      	ldr	r3, [pc, #100]	; (80002bc <endfiniloop+0x1c>)

08000256 <dloop>:
dloop:
                cmp     r2, r3
 8000256:	429a      	cmp	r2, r3
                ittt    lo
 8000258:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800025a:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800025e:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000262:	e7f8      	bcc.n	8000256 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000264:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000266:	4916      	ldr	r1, [pc, #88]	; (80002c0 <endfiniloop+0x20>)
                ldr     r2, =_bss_end
 8000268:	4a16      	ldr	r2, [pc, #88]	; (80002c4 <endfiniloop+0x24>)

0800026a <bloop>:
bloop:
                cmp     r1, r2
 800026a:	4291      	cmp	r1, r2
                itt     lo
 800026c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000272:	e7fa      	bcc.n	800026a <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000274:	f000 ff54 	bl	8001120 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000278:	f000 ff92 	bl	80011a0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800027c:	4c12      	ldr	r4, [pc, #72]	; (80002c8 <endfiniloop+0x28>)
                ldr     r5, =__init_array_end
 800027e:	4d13      	ldr	r5, [pc, #76]	; (80002cc <endfiniloop+0x2c>)

08000280 <initloop>:
initloop:
                cmp     r4, r5
 8000280:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000282:	da03      	bge.n	800028c <endinitloop>
                ldr     r1, [r4], #4
 8000284:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000288:	4788      	blx	r1
                b       initloop
 800028a:	e7f9      	b.n	8000280 <initloop>

0800028c <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800028c:	f000 fb00 	bl	8000890 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000290:	4c0f      	ldr	r4, [pc, #60]	; (80002d0 <endfiniloop+0x30>)
                ldr     r5, =__fini_array_end
 8000292:	4d10      	ldr	r5, [pc, #64]	; (80002d4 <endfiniloop+0x34>)

08000294 <finiloop>:
finiloop:
                cmp     r4, r5
 8000294:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000296:	da03      	bge.n	80002a0 <endfiniloop>
                ldr     r1, [r4], #4
 8000298:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800029c:	4788      	blx	r1
                b       finiloop
 800029e:	e7f9      	b.n	8000294 <finiloop>

080002a0 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80002a0:	f000 bf76 	b.w	8001190 <__default_exit>
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80002a4:	20000800 	.word	0x20000800
#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80002a8:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 80002ac:	20000400 	.word	0x20000400
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80002b0:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 80002b4:	08001b18 	.word	0x08001b18
                ldr     r2, =_data_start
 80002b8:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002bc:	20000824 	.word	0x20000824

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 80002c0:	20000828 	.word	0x20000828
                ldr     r2, =_bss_end
 80002c4:	20000ea0 	.word	0x20000ea0
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002c8:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end
 80002cc:	080001a0 	.word	0x080001a0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002d0:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end
 80002d4:	080001a0 	.word	0x080001a0
	...

080002e0 <chTMStartMeasurementX.constprop.30>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80002e0:	4b01      	ldr	r3, [pc, #4]	; (80002e8 <chTMStartMeasurementX.constprop.30+0x8>)
 80002e2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80002e4:	6083      	str	r3, [r0, #8]
 80002e6:	4770      	bx	lr
 80002e8:	e0001000 	.word	0xe0001000
 80002ec:	00000000 	.word	0x00000000

080002f0 <_pal_lld_setgroupmode.constprop.19>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80002f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 80002f2:	2100      	movs	r1, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80002f4:	2502      	movs	r5, #2
 80002f6:	e008      	b.n	800030a <_pal_lld_setgroupmode.constprop.19+0x1a>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80002f8:	6a1a      	ldr	r2, [r3, #32]
 80002fa:	ea22 0404 	bic.w	r4, r2, r4
 80002fe:	4326      	orrs	r6, r4
 8000300:	621e      	str	r6, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8000302:	0840      	lsrs	r0, r0, #1
 8000304:	d02d      	beq.n	8000362 <_pal_lld_setgroupmode.constprop.19+0x72>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8000306:	00ad      	lsls	r5, r5, #2
    bit++;
 8000308:	3101      	adds	r1, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800030a:	07c3      	lsls	r3, r0, #31
 800030c:	d5f9      	bpl.n	8000302 <_pal_lld_setgroupmode.constprop.19+0x12>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800030e:	4b1f      	ldr	r3, [pc, #124]	; (800038c <_pal_lld_setgroupmode.constprop.19+0x9c>)
 8000310:	2201      	movs	r2, #1
 8000312:	685c      	ldr	r4, [r3, #4]
 8000314:	408a      	lsls	r2, r1
 8000316:	ea24 0202 	bic.w	r2, r4, r2
 800031a:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800031c:	004e      	lsls	r6, r1, #1
 800031e:	2203      	movs	r2, #3
 8000320:	689c      	ldr	r4, [r3, #8]
 8000322:	40b2      	lsls	r2, r6
 8000324:	43d2      	mvns	r2, r2
 8000326:	4014      	ands	r4, r2
 8000328:	609c      	str	r4, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800032a:	68de      	ldr	r6, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800032c:	f001 0407 	and.w	r4, r1, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000330:	4016      	ands	r6, r2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000332:	00a4      	lsls	r4, r4, #2
 8000334:	f04f 0e07 	mov.w	lr, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000338:	270f      	movs	r7, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 800033a:	2d02      	cmp	r5, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800033c:	60de      	str	r6, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800033e:	fa0e f604 	lsl.w	r6, lr, r4
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8000342:	fa07 f404 	lsl.w	r4, r7, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8000346:	d00d      	beq.n	8000364 <_pal_lld_setgroupmode.constprop.19+0x74>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8000348:	681f      	ldr	r7, [r3, #0]
 800034a:	403a      	ands	r2, r7
 800034c:	432a      	orrs	r2, r5
        if (bit < 8)
 800034e:	2907      	cmp	r1, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8000350:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8000352:	d9d1      	bls.n	80002f8 <_pal_lld_setgroupmode.constprop.19+0x8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000354:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000356:	ea22 0404 	bic.w	r4, r2, r4
 800035a:	4326      	orrs	r6, r4
      }
    }
    mask >>= 1;
    if (!mask)
 800035c:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800035e:	625e      	str	r6, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8000360:	d1d1      	bne.n	8000306 <_pal_lld_setgroupmode.constprop.19+0x16>
 8000362:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8000364:	4571      	cmp	r1, lr
 8000366:	d80b      	bhi.n	8000380 <_pal_lld_setgroupmode.constprop.19+0x90>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000368:	6a1f      	ldr	r7, [r3, #32]
 800036a:	ea27 0404 	bic.w	r4, r7, r4
 800036e:	4326      	orrs	r6, r4
 8000370:	621e      	str	r6, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000372:	4c06      	ldr	r4, [pc, #24]	; (800038c <_pal_lld_setgroupmode.constprop.19+0x9c>)
 8000374:	6823      	ldr	r3, [r4, #0]
 8000376:	401a      	ands	r2, r3
 8000378:	f042 0202 	orr.w	r2, r2, #2
 800037c:	6022      	str	r2, [r4, #0]
 800037e:	e7c0      	b.n	8000302 <_pal_lld_setgroupmode.constprop.19+0x12>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000380:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 8000382:	ea27 0404 	bic.w	r4, r7, r4
 8000386:	4326      	orrs	r6, r4
 8000388:	625e      	str	r6, [r3, #36]	; 0x24
 800038a:	e7f2      	b.n	8000372 <_pal_lld_setgroupmode.constprop.19+0x82>
 800038c:	48000800 	.word	0x48000800

08000390 <dmaStreamAllocate.constprop.9>:
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8000390:	b5f0      	push	{r4, r5, r6, r7, lr}
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8000392:	4d28      	ldr	r5, [pc, #160]	; (8000434 <dmaStreamAllocate.constprop.9+0xa4>)
 8000394:	7c44      	ldrb	r4, [r0, #17]
 8000396:	682b      	ldr	r3, [r5, #0]
 8000398:	2201      	movs	r2, #1
 800039a:	fa02 f604 	lsl.w	r6, r2, r4
 800039e:	421e      	tst	r6, r3
 80003a0:	d145      	bne.n	800042e <dmaStreamAllocate.constprop.9+0x9e>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 80003a2:	4a25      	ldr	r2, [pc, #148]	; (8000438 <dmaStreamAllocate.constprop.9+0xa8>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 80003a4:	4e25      	ldr	r6, [pc, #148]	; (800043c <dmaStreamAllocate.constprop.9+0xac>)
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 80003a6:	f842 1034 	str.w	r1, [r2, r4, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 80003aa:	eb02 04c4 	add.w	r4, r2, r4, lsl #3

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 80003ae:	065a      	lsls	r2, r3, #25
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 80003b0:	6066      	str	r6, [r4, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 80003b2:	d104      	bne.n	80003be <dmaStreamAllocate.constprop.9+0x2e>
    rccEnableDMA1(false);
 80003b4:	4c22      	ldr	r4, [pc, #136]	; (8000440 <dmaStreamAllocate.constprop.9+0xb0>)
 80003b6:	6962      	ldr	r2, [r4, #20]
 80003b8:	f042 0201 	orr.w	r2, r2, #1
 80003bc:	6162      	str	r2, [r4, #20]
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 80003be:	f413 6f78 	tst.w	r3, #3968	; 0xf80
 80003c2:	d104      	bne.n	80003ce <dmaStreamAllocate.constprop.9+0x3e>
    rccEnableDMA2(false);
 80003c4:	4c1e      	ldr	r4, [pc, #120]	; (8000440 <dmaStreamAllocate.constprop.9+0xb0>)
 80003c6:	6962      	ldr	r2, [r4, #20]
 80003c8:	f042 0202 	orr.w	r2, r2, #2
 80003cc:	6162      	str	r2, [r4, #20]
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80003ce:	6842      	ldr	r2, [r0, #4]
 80003d0:	6807      	ldr	r7, [r0, #0]
 80003d2:	6814      	ldr	r4, [r2, #0]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 80003d4:	6886      	ldr	r6, [r0, #8]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80003d6:	f024 040f 	bic.w	r4, r4, #15
 80003da:	6014      	str	r4, [r2, #0]
 80003dc:	f890 e010 	ldrb.w	lr, [r0, #16]
 80003e0:	240f      	movs	r4, #15
 80003e2:	fa04 f40e 	lsl.w	r4, r4, lr
 80003e6:	607c      	str	r4, [r7, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 80003e8:	4233      	tst	r3, r6
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80003ea:	f04f 0400 	mov.w	r4, #0
 80003ee:	6014      	str	r4, [r2, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 80003f0:	d116      	bne.n	8000420 <dmaStreamAllocate.constprop.9+0x90>
 80003f2:	b1a9      	cbz	r1, 8000420 <dmaStreamAllocate.constprop.9+0x90>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 80003f4:	7c81      	ldrb	r1, [r0, #18]
 80003f6:	094a      	lsrs	r2, r1, #5
 80003f8:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80003fa:	f101 4660 	add.w	r6, r1, #3758096384	; 0xe0000000
 80003fe:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8000402:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8000406:	f506 4661 	add.w	r6, r6, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800040a:	f001 011f 	and.w	r1, r1, #31
 800040e:	2401      	movs	r4, #1
 8000410:	fa04 f101 	lsl.w	r1, r4, r1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000414:	27c0      	movs	r7, #192	; 0xc0
 8000416:	f886 7300 	strb.w	r7, [r6, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800041a:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800041e:	6011      	str	r1, [r2, #0]
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8000420:	7c41      	ldrb	r1, [r0, #17]
 8000422:	2201      	movs	r2, #1
 8000424:	408a      	lsls	r2, r1
 8000426:	4313      	orrs	r3, r2
 8000428:	602b      	str	r3, [r5, #0]

  return false;
 800042a:	2000      	movs	r0, #0
 800042c:	bdf0      	pop	{r4, r5, r6, r7, pc}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 800042e:	4610      	mov	r0, r2

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);

  return false;
}
 8000430:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000432:	bf00      	nop
 8000434:	20000e9c 	.word	0x20000e9c
 8000438:	20000828 	.word	0x20000828
 800043c:	20000d28 	.word	0x20000d28
 8000440:	40021000 	.word	0x40021000
	...

08000450 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000450:	e7fe      	b.n	8000450 <BusFault_Handler>
 8000452:	bf00      	nop
	...

08000460 <rxend>:
 8000460:	4770      	bx	lr
 8000462:	bf00      	nop
	...

08000470 <chSchWakeupS.constprop.33>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8000470:	4b14      	ldr	r3, [pc, #80]	; (80004c4 <chSchWakeupS.constprop.33+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000472:	b470      	push	{r4, r5, r6}
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000474:	2200      	movs	r2, #0
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000476:	4604      	mov	r4, r0
  thread_t *otp = currp;
 8000478:	691d      	ldr	r5, [r3, #16]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800047a:	6142      	str	r2, [r0, #20]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800047c:	68a8      	ldr	r0, [r5, #8]
 800047e:	68a1      	ldr	r1, [r4, #8]
 8000480:	4281      	cmp	r1, r0
 8000482:	d80b      	bhi.n	800049c <chSchWakeupS.constprop.33+0x2c>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000484:	7422      	strb	r2, [r4, #16]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8000486:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000488:	689a      	ldr	r2, [r3, #8]
 800048a:	4291      	cmp	r1, r2
 800048c:	d9fb      	bls.n	8000486 <chSchWakeupS.constprop.33+0x16>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800048e:	685a      	ldr	r2, [r3, #4]
 8000490:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000492:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8000494:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000496:	605c      	str	r4, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8000498:	bc70      	pop	{r4, r5, r6}
 800049a:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800049c:	742a      	strb	r2, [r5, #16]
  cp = (thread_t *)&ch.rlist.queue;
 800049e:	461a      	mov	r2, r3
  do {
    cp = cp->queue.next;
 80004a0:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 80004a2:	6891      	ldr	r1, [r2, #8]
 80004a4:	4288      	cmp	r0, r1
 80004a6:	d9fb      	bls.n	80004a0 <chSchWakeupS.constprop.33+0x30>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80004a8:	6850      	ldr	r0, [r2, #4]
 80004aa:	6068      	str	r0, [r5, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80004ac:	2601      	movs	r6, #1
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80004ae:	602a      	str	r2, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80004b0:	6005      	str	r5, [r0, #0]
  cp->queue.prev             = tp;
 80004b2:	6055      	str	r5, [r2, #4]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80004b4:	611c      	str	r4, [r3, #16]
    ntp->state = CH_STATE_CURRENT;
 80004b6:	7426      	strb	r6, [r4, #16]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80004b8:	4629      	mov	r1, r5
 80004ba:	4620      	mov	r0, r4
  }
}
 80004bc:	bc70      	pop	{r4, r5, r6}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80004be:	f7ff be6f 	b.w	80001a0 <_port_switch>
 80004c2:	bf00      	nop
 80004c4:	20000904 	.word	0x20000904
	...

080004d0 <chThdCreateStatic.constprop.28>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 80004d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80004d2:	2220      	movs	r2, #32
 80004d4:	4603      	mov	r3, r0
 80004d6:	f382 8811 	msr	BASEPRI, r2
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80004da:	f500 7296 	add.w	r2, r0, #300	; 0x12c
 80004de:	f8c0 116c 	str.w	r1, [r0, #364]	; 0x16c
 80004e2:	2400      	movs	r4, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 80004e4:	f503 71d6 	add.w	r1, r3, #428	; 0x1ac
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 80004e8:	f503 75c8 	add.w	r5, r3, #400	; 0x190
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80004ec:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
 80004f0:	4f10      	ldr	r7, [pc, #64]	; (8000534 <chThdCreateStatic.constprop.28+0x64>)
 80004f2:	f8c3 718c 	str.w	r7, [r3, #396]	; 0x18c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 80004f6:	2280      	movs	r2, #128	; 0x80
  tp->state     = CH_STATE_WTSTART;
 80004f8:	2602      	movs	r6, #2
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 80004fa:	f500 70d4 	add.w	r0, r0, #424	; 0x1a8
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 80004fe:	f8c3 01a8 	str.w	r0, [r3, #424]	; 0x1a8
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000502:	f883 61a0 	strb.w	r6, [r3, #416]	; 0x1a0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000506:	4628      	mov	r0, r5
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000508:	f8c3 11ac 	str.w	r1, [r3, #428]	; 0x1ac
  tqp->prev = (thread_t *)tqp;
 800050c:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000510:	f8c3 4170 	str.w	r4, [r3, #368]	; 0x170
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000514:	f883 41a1 	strb.w	r4, [r3, #417]	; 0x1a1
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000518:	f8c3 41b8 	str.w	r4, [r3, #440]	; 0x1b8
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800051c:	f8c3 41b4 	str.w	r4, [r3, #436]	; 0x1b4
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000520:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000524:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000528:	f7ff ffa2 	bl	8000470 <chSchWakeupS.constprop.33>
 800052c:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();

  return tp;
}
 8000530:	4628      	mov	r0, r5
 8000532:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000534:	080001b9 	.word	0x080001b9
	...

08000540 <Vector130>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8000540:	4b09      	ldr	r3, [pc, #36]	; (8000568 <Vector130+0x28>)
 8000542:	6819      	ldr	r1, [r3, #0]
 8000544:	f3c1 4103 	ubfx	r1, r1, #16, #4
 8000548:	b159      	cbz	r1, 8000562 <Vector130+0x22>
 800054a:	4808      	ldr	r0, [pc, #32]	; (800056c <Vector130+0x2c>)
 800054c:	6d82      	ldr	r2, [r0, #88]	; 0x58
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 800054e:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8000550:	040c      	lsls	r4, r1, #16
 8000552:	605c      	str	r4, [r3, #4]
 8000554:	b10a      	cbz	r2, 800055a <Vector130+0x1a>
 8000556:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8000558:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800055a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);

  OSAL_IRQ_EPILOGUE();
 800055e:	f001 b857 	b.w	8001610 <_port_irq_epilogue>
 8000562:	f001 b855 	b.w	8001610 <_port_irq_epilogue>
 8000566:	bf00      	nop
 8000568:	40020400 	.word	0x40020400
 800056c:	20000828 	.word	0x20000828

08000570 <Vector12C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8000570:	4b09      	ldr	r3, [pc, #36]	; (8000598 <Vector12C+0x28>)
 8000572:	6819      	ldr	r1, [r3, #0]
 8000574:	f3c1 3103 	ubfx	r1, r1, #12, #4
 8000578:	b159      	cbz	r1, 8000592 <Vector12C+0x22>
 800057a:	4808      	ldr	r0, [pc, #32]	; (800059c <Vector12C+0x2c>)
 800057c:	6d02      	ldr	r2, [r0, #80]	; 0x50
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 800057e:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8000580:	030c      	lsls	r4, r1, #12
 8000582:	605c      	str	r4, [r3, #4]
 8000584:	b10a      	cbz	r2, 800058a <Vector12C+0x1a>
 8000586:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8000588:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800058a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);

  OSAL_IRQ_EPILOGUE();
 800058e:	f001 b83f 	b.w	8001610 <_port_irq_epilogue>
 8000592:	f001 b83d 	b.w	8001610 <_port_irq_epilogue>
 8000596:	bf00      	nop
 8000598:	40020400 	.word	0x40020400
 800059c:	20000828 	.word	0x20000828

080005a0 <Vector128>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80005a0:	4b09      	ldr	r3, [pc, #36]	; (80005c8 <Vector128+0x28>)
 80005a2:	6819      	ldr	r1, [r3, #0]
 80005a4:	f3c1 2103 	ubfx	r1, r1, #8, #4
 80005a8:	b159      	cbz	r1, 80005c2 <Vector128+0x22>
 80005aa:	4808      	ldr	r0, [pc, #32]	; (80005cc <Vector128+0x2c>)
 80005ac:	6c82      	ldr	r2, [r0, #72]	; 0x48
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80005ae:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80005b0:	020c      	lsls	r4, r1, #8
 80005b2:	605c      	str	r4, [r3, #4]
 80005b4:	b10a      	cbz	r2, 80005ba <Vector128+0x1a>
 80005b6:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 80005b8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80005ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);

  OSAL_IRQ_EPILOGUE();
 80005be:	f001 b827 	b.w	8001610 <_port_irq_epilogue>
 80005c2:	f001 b825 	b.w	8001610 <_port_irq_epilogue>
 80005c6:	bf00      	nop
 80005c8:	40020400 	.word	0x40020400
 80005cc:	20000828 	.word	0x20000828

080005d0 <Vector124>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80005d0:	4b09      	ldr	r3, [pc, #36]	; (80005f8 <Vector124+0x28>)
 80005d2:	6819      	ldr	r1, [r3, #0]
 80005d4:	f3c1 1103 	ubfx	r1, r1, #4, #4
 80005d8:	b159      	cbz	r1, 80005f2 <Vector124+0x22>
 80005da:	4808      	ldr	r0, [pc, #32]	; (80005fc <Vector124+0x2c>)
 80005dc:	6c02      	ldr	r2, [r0, #64]	; 0x40
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80005de:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80005e0:	010c      	lsls	r4, r1, #4
 80005e2:	605c      	str	r4, [r3, #4]
 80005e4:	b10a      	cbz	r2, 80005ea <Vector124+0x1a>
 80005e6:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80005e8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80005ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);

  OSAL_IRQ_EPILOGUE();
 80005ee:	f001 b80f 	b.w	8001610 <_port_irq_epilogue>
 80005f2:	f001 b80d 	b.w	8001610 <_port_irq_epilogue>
 80005f6:	bf00      	nop
 80005f8:	40020400 	.word	0x40020400
 80005fc:	20000828 	.word	0x20000828

08000600 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8000600:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8000602:	4b07      	ldr	r3, [pc, #28]	; (8000620 <Vector120+0x20>)
 8000604:	6819      	ldr	r1, [r3, #0]
 8000606:	f011 010f 	ands.w	r1, r1, #15
 800060a:	d005      	beq.n	8000618 <Vector120+0x18>
 800060c:	4a05      	ldr	r2, [pc, #20]	; (8000624 <Vector120+0x24>)
 800060e:	6059      	str	r1, [r3, #4]
 8000610:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8000612:	b10b      	cbz	r3, 8000618 <Vector120+0x18>
 8000614:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8000616:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000618:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);

  OSAL_IRQ_EPILOGUE();
 800061c:	f000 bff8 	b.w	8001610 <_port_irq_epilogue>
 8000620:	40020400 	.word	0x40020400
 8000624:	20000828 	.word	0x20000828
	...

08000630 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8000630:	4b09      	ldr	r3, [pc, #36]	; (8000658 <Vector84+0x28>)
 8000632:	6819      	ldr	r1, [r3, #0]
 8000634:	f3c1 6103 	ubfx	r1, r1, #24, #4
 8000638:	b159      	cbz	r1, 8000652 <Vector84+0x22>
 800063a:	4808      	ldr	r0, [pc, #32]	; (800065c <Vector84+0x2c>)
 800063c:	6b02      	ldr	r2, [r0, #48]	; 0x30
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800063e:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8000640:	060c      	lsls	r4, r1, #24
 8000642:	605c      	str	r4, [r3, #4]
 8000644:	b10a      	cbz	r2, 800064a <Vector84+0x1a>
 8000646:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8000648:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800064a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 800064e:	f000 bfdf 	b.w	8001610 <_port_irq_epilogue>
 8000652:	f000 bfdd 	b.w	8001610 <_port_irq_epilogue>
 8000656:	bf00      	nop
 8000658:	40020000 	.word	0x40020000
 800065c:	20000828 	.word	0x20000828

08000660 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8000660:	4b09      	ldr	r3, [pc, #36]	; (8000688 <Vector80+0x28>)
 8000662:	6819      	ldr	r1, [r3, #0]
 8000664:	f3c1 5103 	ubfx	r1, r1, #20, #4
 8000668:	b159      	cbz	r1, 8000682 <Vector80+0x22>
 800066a:	4808      	ldr	r0, [pc, #32]	; (800068c <Vector80+0x2c>)
 800066c:	6a82      	ldr	r2, [r0, #40]	; 0x28
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800066e:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8000670:	050c      	lsls	r4, r1, #20
 8000672:	605c      	str	r4, [r3, #4]
 8000674:	b10a      	cbz	r2, 800067a <Vector80+0x1a>
 8000676:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8000678:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800067a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 800067e:	f000 bfc7 	b.w	8001610 <_port_irq_epilogue>
 8000682:	f000 bfc5 	b.w	8001610 <_port_irq_epilogue>
 8000686:	bf00      	nop
 8000688:	40020000 	.word	0x40020000
 800068c:	20000828 	.word	0x20000828

08000690 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000690:	4b09      	ldr	r3, [pc, #36]	; (80006b8 <Vector7C+0x28>)
 8000692:	6819      	ldr	r1, [r3, #0]
 8000694:	f3c1 4103 	ubfx	r1, r1, #16, #4
 8000698:	b159      	cbz	r1, 80006b2 <Vector7C+0x22>
 800069a:	4808      	ldr	r0, [pc, #32]	; (80006bc <Vector7C+0x2c>)
 800069c:	6a02      	ldr	r2, [r0, #32]
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800069e:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80006a0:	040c      	lsls	r4, r1, #16
 80006a2:	605c      	str	r4, [r3, #4]
 80006a4:	b10a      	cbz	r2, 80006aa <Vector7C+0x1a>
 80006a6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80006a8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80006aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 80006ae:	f000 bfaf 	b.w	8001610 <_port_irq_epilogue>
 80006b2:	f000 bfad 	b.w	8001610 <_port_irq_epilogue>
 80006b6:	bf00      	nop
 80006b8:	40020000 	.word	0x40020000
 80006bc:	20000828 	.word	0x20000828

080006c0 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80006c0:	4b09      	ldr	r3, [pc, #36]	; (80006e8 <Vector78+0x28>)
 80006c2:	6819      	ldr	r1, [r3, #0]
 80006c4:	f3c1 3103 	ubfx	r1, r1, #12, #4
 80006c8:	b159      	cbz	r1, 80006e2 <Vector78+0x22>
 80006ca:	4808      	ldr	r0, [pc, #32]	; (80006ec <Vector78+0x2c>)
 80006cc:	6982      	ldr	r2, [r0, #24]
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80006ce:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80006d0:	030c      	lsls	r4, r1, #12
 80006d2:	605c      	str	r4, [r3, #4]
 80006d4:	b10a      	cbz	r2, 80006da <Vector78+0x1a>
 80006d6:	69c0      	ldr	r0, [r0, #28]
 80006d8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80006da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 80006de:	f000 bf97 	b.w	8001610 <_port_irq_epilogue>
 80006e2:	f000 bf95 	b.w	8001610 <_port_irq_epilogue>
 80006e6:	bf00      	nop
 80006e8:	40020000 	.word	0x40020000
 80006ec:	20000828 	.word	0x20000828

080006f0 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80006f0:	4b09      	ldr	r3, [pc, #36]	; (8000718 <Vector74+0x28>)
 80006f2:	6819      	ldr	r1, [r3, #0]
 80006f4:	f3c1 2103 	ubfx	r1, r1, #8, #4
 80006f8:	b159      	cbz	r1, 8000712 <Vector74+0x22>
 80006fa:	4808      	ldr	r0, [pc, #32]	; (800071c <Vector74+0x2c>)
 80006fc:	6902      	ldr	r2, [r0, #16]
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80006fe:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000700:	020c      	lsls	r4, r1, #8
 8000702:	605c      	str	r4, [r3, #4]
 8000704:	b10a      	cbz	r2, 800070a <Vector74+0x1a>
 8000706:	6940      	ldr	r0, [r0, #20]
 8000708:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800070a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 800070e:	f000 bf7f 	b.w	8001610 <_port_irq_epilogue>
 8000712:	f000 bf7d 	b.w	8001610 <_port_irq_epilogue>
 8000716:	bf00      	nop
 8000718:	40020000 	.word	0x40020000
 800071c:	20000828 	.word	0x20000828

08000720 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000720:	4b09      	ldr	r3, [pc, #36]	; (8000748 <Vector70+0x28>)
 8000722:	6819      	ldr	r1, [r3, #0]
 8000724:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8000728:	b159      	cbz	r1, 8000742 <Vector70+0x22>
 800072a:	4808      	ldr	r0, [pc, #32]	; (800074c <Vector70+0x2c>)
 800072c:	6882      	ldr	r2, [r0, #8]
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800072e:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000730:	010c      	lsls	r4, r1, #4
 8000732:	605c      	str	r4, [r3, #4]
 8000734:	b10a      	cbz	r2, 800073a <Vector70+0x1a>
 8000736:	68c0      	ldr	r0, [r0, #12]
 8000738:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 800073a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 800073e:	f000 bf67 	b.w	8001610 <_port_irq_epilogue>
 8000742:	f000 bf65 	b.w	8001610 <_port_irq_epilogue>
 8000746:	bf00      	nop
 8000748:	40020000 	.word	0x40020000
 800074c:	20000828 	.word	0x20000828

08000750 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8000750:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8000752:	4b07      	ldr	r3, [pc, #28]	; (8000770 <Vector6C+0x20>)
 8000754:	6819      	ldr	r1, [r3, #0]
 8000756:	f011 010f 	ands.w	r1, r1, #15
 800075a:	d005      	beq.n	8000768 <Vector6C+0x18>
 800075c:	4a05      	ldr	r2, [pc, #20]	; (8000774 <Vector6C+0x24>)
 800075e:	6059      	str	r1, [r3, #4]
 8000760:	6813      	ldr	r3, [r2, #0]
 8000762:	b10b      	cbz	r3, 8000768 <Vector6C+0x18>
 8000764:	6850      	ldr	r0, [r2, #4]
 8000766:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000768:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 800076c:	f000 bf50 	b.w	8001610 <_port_irq_epilogue>
 8000770:	40020000 	.word	0x40020000
 8000774:	20000828 	.word	0x20000828
	...

08000780 <Task_50ms>:
};

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_FUNCTION(Task_50ms, arg) {
 8000780:	b508      	push	{r3, lr}
 8000782:	4c0a      	ldr	r4, [pc, #40]	; (80007ac <Task_50ms+0x2c>)
 8000784:	e00b      	b.n	800079e <Task_50ms+0x1e>
 8000786:	b2db      	uxtb	r3, r3
 8000788:	2220      	movs	r2, #32
	{
		swTimer_set(rub_LedTimeout, 10);

	}

	swTimer_tick(rub_LedTimeout);
 800078a:	7023      	strb	r3, [r4, #0]
 800078c:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000790:	2132      	movs	r1, #50	; 0x32
 8000792:	2008      	movs	r0, #8
 8000794:	f000 fd5c 	bl	8001250 <chSchGoSleepTimeoutS>
 8000798:	2300      	movs	r3, #0
 800079a:	f383 8811 	msr	BASEPRI, r3
static THD_FUNCTION(Task_50ms, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
  while (TRUE) {
	if (swTimer_isElapsed(rub_LedTimeout))
 800079e:	7822      	ldrb	r2, [r4, #0]
 80007a0:	1e53      	subs	r3, r2, #1
 80007a2:	2a00      	cmp	r2, #0
 80007a4:	d1ef      	bne.n	8000786 <Task_50ms+0x6>
 80007a6:	2309      	movs	r3, #9
 80007a8:	e7ee      	b.n	8000788 <Task_50ms+0x8>
 80007aa:	bf00      	nop
 80007ac:	20000e98 	.word	0x20000e98

080007b0 <Task_5ms>:
}

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_FUNCTION(Task_5ms, arg) {
 80007b0:	b508      	push	{r3, lr}
 80007b2:	2320      	movs	r3, #32
 80007b4:	f383 8811 	msr	BASEPRI, r3
 80007b8:	2105      	movs	r1, #5
 80007ba:	2008      	movs	r0, #8
 80007bc:	f000 fd48 	bl	8001250 <chSchGoSleepTimeoutS>
 80007c0:	2300      	movs	r3, #0
 80007c2:	f383 8811 	msr	BASEPRI, r3
 80007c6:	e7f4      	b.n	80007b2 <Task_5ms+0x2>
	...

080007d0 <rxchar>:

/*
 * This callback is invoked when a character is received but the application
 * was not ready to receive it, the character is passed as parameter.
 */
static void rxchar(UARTDriver *uartp, uint16_t c) {
 80007d0:	b500      	push	{lr}
	uint8_t val = (uint8_t)c;
	(void)uartp;
	rbi_LedStatus ^= 1u;
 80007d2:	4b0f      	ldr	r3, [pc, #60]	; (8000810 <rxchar+0x40>)
 80007d4:	781a      	ldrb	r2, [r3, #0]
 80007d6:	f082 0201 	eor.w	r2, r2, #1
 80007da:	701a      	strb	r2, [r3, #0]

/*
 * This callback is invoked when a character is received but the application
 * was not ready to receive it, the character is passed as parameter.
 */
static void rxchar(UARTDriver *uartp, uint16_t c) {
 80007dc:	b083      	sub	sp, #12
	uint8_t val = (uint8_t)c;
	(void)uartp;
	rbi_LedStatus ^= 1u;
	if (rbi_LedStatus == FALSE)
 80007de:	781b      	ldrb	r3, [r3, #0]
/*
 * This callback is invoked when a character is received but the application
 * was not ready to receive it, the character is passed as parameter.
 */
static void rxchar(UARTDriver *uartp, uint16_t c) {
	uint8_t val = (uint8_t)c;
 80007e0:	f88d 1007 	strb.w	r1, [sp, #7]
	(void)uartp;
	rbi_LedStatus ^= 1u;
	if (rbi_LedStatus == FALSE)
 80007e4:	b173      	cbz	r3, 8000804 <rxchar+0x34>
	{
		palClearPad(GPIOA, GPIOA_LED_GREEN);
	}
	else
	{
		palSetPad(GPIOA, GPIOA_LED_GREEN);
 80007e6:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 80007ea:	2220      	movs	r2, #32
 80007ec:	831a      	strh	r2, [r3, #24]
	}
    /* Flashing the LED each time a character is received.*/
    sdWrite(&SD2, (uint8_t *)&val, 1);
 80007ee:	f04f 33ff 	mov.w	r3, #4294967295
 80007f2:	2201      	movs	r2, #1
 80007f4:	f10d 0107 	add.w	r1, sp, #7
 80007f8:	4806      	ldr	r0, [pc, #24]	; (8000814 <rxchar+0x44>)
 80007fa:	f000 fd81 	bl	8001300 <oqWriteTimeout>
}
 80007fe:	b003      	add	sp, #12
 8000800:	f85d fb04 	ldr.w	pc, [sp], #4
	uint8_t val = (uint8_t)c;
	(void)uartp;
	rbi_LedStatus ^= 1u;
	if (rbi_LedStatus == FALSE)
	{
		palClearPad(GPIOA, GPIOA_LED_GREEN);
 8000804:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8000808:	2220      	movs	r2, #32
 800080a:	835a      	strh	r2, [r3, #26]
 800080c:	e7ef      	b.n	80007ee <rxchar+0x1e>
 800080e:	bf00      	nop
 8000810:	20000960 	.word	0x20000960
 8000814:	200008b8 	.word	0x200008b8
	...

08000820 <chEvtBroadcastFlagsI.constprop.35>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000820:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8000822:	4e17      	ldr	r6, [pc, #92]	; (8000880 <chEvtBroadcastFlagsI.constprop.35+0x60>)
 8000824:	f856 4f04 	ldr.w	r4, [r6, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000828:	42b4      	cmp	r4, r6
 800082a:	d020      	beq.n	800086e <chEvtBroadcastFlagsI.constprop.35+0x4e>
 800082c:	4605      	mov	r5, r0
 800082e:	e002      	b.n	8000836 <chEvtBroadcastFlagsI.constprop.35+0x16>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8000830:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000832:	42b4      	cmp	r4, r6
 8000834:	d01b      	beq.n	800086e <chEvtBroadcastFlagsI.constprop.35+0x4e>
  /*lint -restore*/
    elp->flags |= flags;
 8000836:	68e3      	ldr	r3, [r4, #12]
 8000838:	432b      	orrs	r3, r5
 800083a:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800083c:	b115      	cbz	r5, 8000844 <chEvtBroadcastFlagsI.constprop.35+0x24>
 800083e:	6922      	ldr	r2, [r4, #16]
 8000840:	4213      	tst	r3, r2
 8000842:	d0f5      	beq.n	8000830 <chEvtBroadcastFlagsI.constprop.35+0x10>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8000844:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000846:	68a1      	ldr	r1, [r4, #8]
 8000848:	6a43      	ldr	r3, [r0, #36]	; 0x24
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800084a:	7c02      	ldrb	r2, [r0, #16]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 800084c:	430b      	orrs	r3, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800084e:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000850:	6243      	str	r3, [r0, #36]	; 0x24
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000852:	d00d      	beq.n	8000870 <chEvtBroadcastFlagsI.constprop.35+0x50>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000854:	2a0b      	cmp	r2, #11
 8000856:	d1eb      	bne.n	8000830 <chEvtBroadcastFlagsI.constprop.35+0x10>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000858:	6942      	ldr	r2, [r0, #20]

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 800085a:	ea32 0303 	bics.w	r3, r2, r3
 800085e:	d1e7      	bne.n	8000830 <chEvtBroadcastFlagsI.constprop.35+0x10>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000860:	2300      	movs	r3, #0
 8000862:	6143      	str	r3, [r0, #20]
    (void) chSchReadyI(tp);
 8000864:	f000 fe9c 	bl	80015a0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8000868:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800086a:	42b4      	cmp	r4, r6
 800086c:	d1e3      	bne.n	8000836 <chEvtBroadcastFlagsI.constprop.35+0x16>
 800086e:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000870:	6942      	ldr	r2, [r0, #20]
 8000872:	4213      	tst	r3, r2
 8000874:	d0dc      	beq.n	8000830 <chEvtBroadcastFlagsI.constprop.35+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000876:	2300      	movs	r3, #0
 8000878:	6143      	str	r3, [r0, #20]
    (void) chSchReadyI(tp);
 800087a:	f000 fe91 	bl	80015a0 <chSchReadyI>
 800087e:	e7f3      	b.n	8000868 <chEvtBroadcastFlagsI.constprop.35+0x48>
 8000880:	20000888 	.word	0x20000888
	...

08000890 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000890:	4b1a      	ldr	r3, [pc, #104]	; (80008fc <main+0x6c>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000892:	481b      	ldr	r0, [pc, #108]	; (8000900 <main+0x70>)
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000894:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000896:	f04f 31ff 	mov.w	r1, #4294967295
 800089a:	2200      	movs	r2, #0
}

/*
 * Application entry point.
 */
void main(void) {
 800089c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80008a0:	6299      	str	r1, [r3, #40]	; 0x28
 80008a2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80008a4:	691c      	ldr	r4, [r3, #16]
 80008a6:	6119      	str	r1, [r3, #16]
 80008a8:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 80008aa:	68dc      	ldr	r4, [r3, #12]
 80008ac:	60d9      	str	r1, [r3, #12]
 80008ae:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80008b0:	69d9      	ldr	r1, [r3, #28]
 80008b2:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80008b6:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80008b8:	6801      	ldr	r1, [r0, #0]
 80008ba:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80008be:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80008c0:	6a19      	ldr	r1, [r3, #32]
 80008c2:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80008c6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80008ca:	b089      	sub	sp, #36	; 0x24
 80008cc:	d003      	beq.n	80008d6 <main+0x46>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80008ce:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80008d2:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 80008d4:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80008d6:	4b09      	ldr	r3, [pc, #36]	; (80008fc <main+0x6c>)
 80008d8:	6a1a      	ldr	r2, [r3, #32]
 80008da:	0412      	lsls	r2, r2, #16
 80008dc:	d407      	bmi.n	80008ee <main+0x5e>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80008de:	6a1a      	ldr	r2, [r3, #32]
 80008e0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80008e4:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80008e6:	6a1a      	ldr	r2, [r3, #32]
 80008e8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80008ec:	621a      	str	r2, [r3, #32]
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 80008ee:	4c05      	ldr	r4, [pc, #20]	; (8000904 <main+0x74>)
 80008f0:	4a05      	ldr	r2, [pc, #20]	; (8000908 <main+0x78>)
 80008f2:	4906      	ldr	r1, [pc, #24]	; (800090c <main+0x7c>)
 80008f4:	4806      	ldr	r0, [pc, #24]	; (8000910 <main+0x80>)
 80008f6:	2300      	movs	r3, #0
 80008f8:	6023      	str	r3, [r4, #0]
 80008fa:	e00c      	b.n	8000916 <main+0x86>
 80008fc:	40021000 	.word	0x40021000
 8000900:	40007000 	.word	0x40007000
 8000904:	20000e9c 	.word	0x20000e9c
 8000908:	0800197c 	.word	0x0800197c
 800090c:	40020008 	.word	0x40020008
 8000910:	20000828 	.word	0x20000828
 8000914:	6851      	ldr	r1, [r2, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 8000916:	2400      	movs	r4, #0
 8000918:	600c      	str	r4, [r1, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 800091a:	f840 4033 	str.w	r4, [r0, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800091e:	3301      	adds	r3, #1
 8000920:	2b0c      	cmp	r3, #12
 8000922:	f102 0214 	add.w	r2, r2, #20
 8000926:	d1f5      	bne.n	8000914 <main+0x84>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8000928:	4fcd      	ldr	r7, [pc, #820]	; (8000c60 <main+0x3d0>)
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 800092a:	49ce      	ldr	r1, [pc, #824]	; (8000c64 <main+0x3d4>)
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800092c:	f8df a374 	ldr.w	sl, [pc, #884]	; 8000ca4 <main+0x414>

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8000930:	f8df b374 	ldr.w	fp, [pc, #884]	; 8000ca8 <main+0x418>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000934:	f8df 9374 	ldr.w	r9, [pc, #884]	; 8000cac <main+0x41c>
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8000938:	4dcb      	ldr	r5, [pc, #812]	; (8000c68 <main+0x3d8>)
 800093a:	f8df 8374 	ldr.w	r8, [pc, #884]	; 8000cb0 <main+0x420>
 800093e:	f8df c374 	ldr.w	ip, [pc, #884]	; 8000cb4 <main+0x424>
 8000942:	f8df e374 	ldr.w	lr, [pc, #884]	; 8000cb8 <main+0x428>
 8000946:	4ec9      	ldr	r6, [pc, #804]	; (8000c6c <main+0x3dc>)
 8000948:	48c9      	ldr	r0, [pc, #804]	; (8000c70 <main+0x3e0>)
 800094a:	4aca      	ldr	r2, [pc, #808]	; (8000c74 <main+0x3e4>)
  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 800094c:	f04f 33ff 	mov.w	r3, #4294967295
 8000950:	607b      	str	r3, [r7, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8000952:	604b      	str	r3, [r1, #4]
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000954:	f8da 1018 	ldr.w	r1, [sl, #24]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000958:	4fc7      	ldr	r7, [pc, #796]	; (8000c78 <main+0x3e8>)
 800095a:	f041 0101 	orr.w	r1, r1, #1
 800095e:	f8ca 1018 	str.w	r1, [sl, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8000962:	f8db 1000 	ldr.w	r1, [fp]
 8000966:	f041 0120 	orr.w	r1, r1, #32
 800096a:	f8cb 1000 	str.w	r1, [fp]
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 800096e:	f8da b014 	ldr.w	fp, [sl, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000972:	f04f 4190 	mov.w	r1, #1207959552	; 0x48000000
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000976:	f44b 0b7f 	orr.w	fp, fp, #16711680	; 0xff0000
 800097a:	f8ca b014 	str.w	fp, [sl, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800097e:	f46f 6b0a 	mvn.w	fp, #2208	; 0x8a0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000982:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000984:	f8c1 b008 	str.w	fp, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000988:	f64f 7bdf 	movw	fp, #65503	; 0xffdf

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800098c:	60cf      	str	r7, [r1, #12]
  gpiop->ODR     = config->odr;
 800098e:	f8c1 b014 	str.w	fp, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000992:	f44f 47ee 	mov.w	r7, #30464	; 0x7700
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000996:	f8df b324 	ldr.w	fp, [pc, #804]	; 8000cbc <main+0x42c>

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800099a:	620f      	str	r7, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800099c:	624c      	str	r4, [r1, #36]	; 0x24

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800099e:	f04f 3755 	mov.w	r7, #1431655765	; 0x55555555
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80009a2:	f8c1 b000 	str.w	fp, [r1]
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80009a6:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80009aa:	f04f 0b80 	mov.w	fp, #128	; 0x80
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80009ae:	f8c9 4004 	str.w	r4, [r9, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80009b2:	f8c9 3008 	str.w	r3, [r9, #8]
  gpiop->PUPDR   = config->pupdr;
 80009b6:	f8c9 700c 	str.w	r7, [r9, #12]
  gpiop->ODR     = config->odr;
 80009ba:	f8c9 1014 	str.w	r1, [r9, #20]
  gpiop->AFRL    = config->afrl;
 80009be:	f8c9 4020 	str.w	r4, [r9, #32]
  gpiop->AFRH    = config->afrh;
 80009c2:	f8c9 4024 	str.w	r4, [r9, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80009c6:	f8c9 b000 	str.w	fp, [r9]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80009ca:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 8000cc0 <main+0x430>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80009ce:	f8c8 4004 	str.w	r4, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80009d2:	f8c8 3008 	str.w	r3, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
 80009d6:	f8c8 900c 	str.w	r9, [r8, #12]
  gpiop->ODR     = config->odr;
 80009da:	f8c8 1014 	str.w	r1, [r8, #20]
  gpiop->AFRL    = config->afrl;
 80009de:	f8c8 4020 	str.w	r4, [r8, #32]
  gpiop->AFRH    = config->afrh;
 80009e2:	f8c8 4024 	str.w	r4, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80009e6:	f8c8 4000 	str.w	r4, [r8]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80009ea:	f8cc 4004 	str.w	r4, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80009ee:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 80009f2:	f8cc 700c 	str.w	r7, [ip, #12]
  gpiop->ODR     = config->odr;
 80009f6:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
 80009fa:	f8cc 4020 	str.w	r4, [ip, #32]
  gpiop->AFRH    = config->afrh;
 80009fe:	f8cc 4024 	str.w	r4, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000a02:	f8cc 4000 	str.w	r4, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000a06:	f8ce 4004 	str.w	r4, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000a0a:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 8000a0e:	f8ce 700c 	str.w	r7, [lr, #12]
  gpiop->ODR     = config->odr;
 8000a12:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8000a16:	f8ce 4020 	str.w	r4, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8000a1a:	f8ce 4024 	str.w	r4, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000a1e:	f8ce 4000 	str.w	r4, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000a22:	6074      	str	r4, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000a24:	60b3      	str	r3, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8000a26:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 8000a28:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8000a2a:	6234      	str	r4, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8000a2c:	6274      	str	r4, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000a2e:	6034      	str	r4, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000a30:	6044      	str	r4, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000a32:	6084      	str	r4, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8000a34:	60c7      	str	r7, [r0, #12]
  gpiop->ODR     = config->odr;
 8000a36:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8000a38:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8000a3a:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000a3c:	6004      	str	r4, [r0, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000a3e:	6054      	str	r4, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000a40:	6094      	str	r4, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000a42:	60d7      	str	r7, [r2, #12]
  gpiop->ODR     = config->odr;
 8000a44:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000a46:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000a48:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000a4a:	6014      	str	r4, [r2, #0]
 8000a4c:	462a      	mov	r2, r5
 8000a4e:	f8df 9274 	ldr.w	r9, [pc, #628]	; 8000cc4 <main+0x434>
 8000a52:	f842 9b04 	str.w	r9, [r2], #4
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
 8000a56:	4e89      	ldr	r6, [pc, #548]	; (8000c7c <main+0x3ec>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000a58:	f8df e26c 	ldr.w	lr, [pc, #620]	; 8000cc8 <main+0x438>
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8000a5c:	f8df 926c 	ldr.w	r9, [pc, #620]	; 8000ccc <main+0x43c>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000a60:	606a      	str	r2, [r5, #4]
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000a62:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8000a66:	6429      	str	r1, [r5, #64]	; 0x40
  oqp->q_notify  = onfy;
 8000a68:	f8c5 904c 	str.w	r9, [r5, #76]	; 0x4c
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000a6c:	2110      	movs	r1, #16
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8000a6e:	4a84      	ldr	r2, [pc, #528]	; (8000c80 <main+0x3f0>)
 8000a70:	9101      	str	r1, [sp, #4]
 8000a72:	f04f 09c0 	mov.w	r9, #192	; 0xc0
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000a76:	616c      	str	r4, [r5, #20]
 8000a78:	676a      	str	r2, [r5, #116]	; 0x74
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000a7a:	63a9      	str	r1, [r5, #56]	; 0x38
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8000a7c:	62ac      	str	r4, [r5, #40]	; 0x28
  iqp->q_link    = link;
 8000a7e:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000a80:	652d      	str	r5, [r5, #80]	; 0x50
  uartp->txstate    = UART_TX_IDLE;
  uartp->rxstate    = UART_RX_IDLE;
  uartp->config     = NULL;
 8000a82:	6074      	str	r4, [r6, #4]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000a84:	2240      	movs	r2, #64	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000a86:	f88e 9326 	strb.w	r9, [lr, #806]	; 0x326
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000a8a:	f04f 0901 	mov.w	r9, #1
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000a8e:	f8ce 2184 	str.w	r2, [lr, #388]	; 0x184
 8000a92:	f885 9008 	strb.w	r9, [r5, #8]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000a96:	f8ce 2004 	str.w	r2, [lr, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000a9a:	f105 020c 	add.w	r2, r5, #12
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000a9e:	f105 0e54 	add.w	lr, r5, #84	; 0x54
 8000aa2:	60ea      	str	r2, [r5, #12]
  tqp->prev = (thread_t *)tqp;
 8000aa4:	612a      	str	r2, [r5, #16]
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8000aa6:	f105 0264 	add.w	r2, r5, #100	; 0x64
#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
  UARTD3.usart   = USART3;
  UARTD3.clock   = STM32_USART3CLK;
  UARTD3.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
  UARTD3.dmarx   = STM32_DMA_STREAM(STM32_UART_USART3_RX_DMA_STREAM);
 8000aaa:	f8df c224 	ldr.w	ip, [pc, #548]	; 8000cd0 <main+0x440>
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000aae:	f8c5 e018 	str.w	lr, [r5, #24]
  iqp->q_rdptr   = bp;
 8000ab2:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8000ab6:	f8c5 e020 	str.w	lr, [r5, #32]
  iqp->q_top     = bp + size;
 8000aba:	61ea      	str	r2, [r5, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000abc:	f105 0e30 	add.w	lr, r5, #48	; 0x30
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8000ac0:	63ea      	str	r2, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8000ac2:	64aa      	str	r2, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8000ac4:	646a      	str	r2, [r5, #68]	; 0x44
  SD2.clock = STM32_USART2CLK;
 8000ac6:	4a6f      	ldr	r2, [pc, #444]	; (8000c84 <main+0x3f4>)
 8000ac8:	4f6f      	ldr	r7, [pc, #444]	; (8000c88 <main+0x3f8>)
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 8000aca:	f8df 8208 	ldr.w	r8, [pc, #520]	; 8000cd4 <main+0x444>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8000ace:	486f      	ldr	r0, [pc, #444]	; (8000c8c <main+0x3fc>)
 8000ad0:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8000ad4:	f8c5 e034 	str.w	lr, [r5, #52]	; 0x34
 8000ad8:	67aa      	str	r2, [r5, #120]	; 0x78
#endif

#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
  UARTD3.usart   = USART3;
  UARTD3.clock   = STM32_USART3CLK;
 8000ada:	60f2      	str	r2, [r6, #12]
  UARTD2.dmatx   = STM32_DMA_STREAM(STM32_UART_USART2_TX_DMA_STREAM);
#endif

#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
  UARTD3.usart   = USART3;
 8000adc:	f8df e1f8 	ldr.w	lr, [pc, #504]	; 8000cd8 <main+0x448>
 8000ae0:	f8c6 e008 	str.w	lr, [r6, #8]
  UARTD3.clock   = STM32_USART3CLK;
  UARTD3.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8000ae4:	2208      	movs	r2, #8
  UARTD3.dmarx   = STM32_DMA_STREAM(STM32_UART_USART3_RX_DMA_STREAM);
  UARTD3.dmatx   = STM32_DMA_STREAM(STM32_UART_USART3_TX_DMA_STREAM);
 8000ae6:	f1ac 0e14 	sub.w	lr, ip, #20

#if STM32_UART_USE_USART3
  uartObjectInit(&UARTD3);
  UARTD3.usart   = USART3;
  UARTD3.clock   = STM32_USART3CLK;
  UARTD3.dmamode = STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE;
 8000aea:	6132      	str	r2, [r6, #16]
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
 8000aec:	f886 9000 	strb.w	r9, [r6]
  uartp->txstate    = UART_TX_IDLE;
 8000af0:	7074      	strb	r4, [r6, #1]
  uartp->rxstate    = UART_RX_IDLE;
 8000af2:	70b4      	strb	r4, [r6, #2]
 8000af4:	4a66      	ldr	r2, [pc, #408]	; (8000c90 <main+0x400>)
  UARTD3.dmarx   = STM32_DMA_STREAM(STM32_UART_USART3_RX_DMA_STREAM);
 8000af6:	f8c6 c014 	str.w	ip, [r6, #20]
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8000afa:	f04f 0c07 	mov.w	ip, #7
  UARTD3.dmatx   = STM32_DMA_STREAM(STM32_UART_USART3_TX_DMA_STREAM);
 8000afe:	f8c6 e018 	str.w	lr, [r6, #24]
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8000b02:	6042      	str	r2, [r0, #4]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000b04:	f107 0e14 	add.w	lr, r7, #20
  SysTick->VAL = 0;
 8000b08:	6084      	str	r4, [r0, #8]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000b0a:	2200      	movs	r2, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8000b0c:	f8c0 c000 	str.w	ip, [r0]
 8000b10:	f888 b023 	strb.w	fp, [r8, #35]	; 0x23
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000b14:	a802      	add	r0, sp, #8
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8000b16:	9302      	str	r3, [sp, #8]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8000b18:	61fb      	str	r3, [r7, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000b1a:	603f      	str	r7, [r7, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000b1c:	2300      	movs	r3, #0
  tqp->prev = (thread_t *)tqp;
 8000b1e:	607f      	str	r7, [r7, #4]
 8000b20:	e9cd 2306 	strd	r2, r3, [sp, #24]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000b24:	f8c7 e014 	str.w	lr, [r7, #20]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000b28:	f8c7 e018 	str.w	lr, [r7, #24]
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8000b2c:	9403      	str	r4, [sp, #12]
  tmp->last       = (rtcnt_t)0;
 8000b2e:	9404      	str	r4, [sp, #16]
  tmp->n          = (ucnt_t)0;
 8000b30:	9405      	str	r4, [sp, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000b32:	60bc      	str	r4, [r7, #8]
  ch.vtlist.delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
 8000b34:	623c      	str	r4, [r7, #32]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000b36:	65bc      	str	r4, [r7, #88]	; 0x58
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000b38:	f7ff fbd2 	bl	80002e0 <chTMStartMeasurementX.constprop.30>
  chTMStopMeasurementX(&tm);
 8000b3c:	a802      	add	r0, sp, #8
 8000b3e:	f000 fb3f 	bl	80011c0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8000b42:	9b04      	ldr	r3, [sp, #16]
 8000b44:	65bb      	str	r3, [r7, #88]	; 0x58
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000b46:	f8c8 4008 	str.w	r4, [r8, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000b4a:	f8d8 c00c 	ldr.w	ip, [r8, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000b4e:	4b51      	ldr	r3, [pc, #324]	; (8000c94 <main+0x404>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000b50:	f8df e188 	ldr.w	lr, [pc, #392]	; 8000cdc <main+0x44c>
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000b54:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8000b58:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 8000b5c:	ea0c 0202 	and.w	r2, ip, r2
  reg_value  =  (reg_value                                   |
 8000b60:	4313      	orrs	r3, r2
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000b62:	f8c8 300c 	str.w	r3, [r8, #12]
 8000b66:	f8de 300c 	ldr.w	r3, [lr, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000b6a:	484b      	ldr	r0, [pc, #300]	; (8000c98 <main+0x408>)
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000b6c:	f887 4039 	strb.w	r4, [r7, #57]	; 0x39

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000b70:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000b74:	f8ce 300c 	str.w	r3, [lr, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000b78:	6803      	ldr	r3, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b7a:	9901      	ldr	r1, [sp, #4]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000b7c:	f8c7 b054 	str.w	fp, [r7, #84]	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000b80:	f107 0c44 	add.w	ip, r7, #68	; 0x44
 8000b84:	ea43 0309 	orr.w	r3, r3, r9
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000b88:	f107 0e40 	add.w	lr, r7, #64	; 0x40
#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
#else
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 8000b8c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8000b90:	f04f 0b20 	mov.w	fp, #32
  tp->mtxlist   = NULL;
 8000b94:	653c      	str	r4, [r7, #80]	; 0x50
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000b96:	64fc      	str	r4, [r7, #76]	; 0x4c
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000b98:	f887 9038 	strb.w	r9, [r7, #56]	; 0x38
 8000b9c:	6003      	str	r3, [r0, #0]
 8000b9e:	f8c7 e040 	str.w	lr, [r7, #64]	; 0x40
 8000ba2:	f888 101f 	strb.w	r1, [r8, #31]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
#else
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 8000ba6:	613a      	str	r2, [r7, #16]
 8000ba8:	f888 b022 	strb.w	fp, [r8, #34]	; 0x22
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bac:	f8c7 c044 	str.w	ip, [r7, #68]	; 0x44
  tqp->prev = (thread_t *)tqp;
 8000bb0:	f8c7 c048 	str.w	ip, [r7, #72]	; 0x48
 8000bb4:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000bb8:	b662      	cpsie	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000bba:	f38b 8811 	msr	BASEPRI, fp
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000bbe:	4b37      	ldr	r3, [pc, #220]	; (8000c9c <main+0x40c>)
 8000bc0:	f8df c11c 	ldr.w	ip, [pc, #284]	; 8000ce0 <main+0x450>
 8000bc4:	f8df e11c 	ldr.w	lr, [pc, #284]	; 8000ce4 <main+0x454>
 8000bc8:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bcc:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8000bd0:	f103 08bc 	add.w	r8, r3, #188	; 0xbc
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000bd4:	f503 719c 	add.w	r1, r3, #312	; 0x138
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000bd8:	2702      	movs	r7, #2
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 8000bda:	f503 7090 	add.w	r0, r3, #288	; 0x120
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000bde:	f8c3 9128 	str.w	r9, [r3, #296]	; 0x128
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000be2:	f883 4131 	strb.w	r4, [r3, #305]	; 0x131
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000be6:	f8c3 914c 	str.w	r9, [r3, #332]	; 0x14c
  tp->mtxlist   = NULL;
 8000bea:	f8c3 4148 	str.w	r4, [r3, #328]	; 0x148
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000bee:	f8c3 4144 	str.w	r4, [r3, #324]	; 0x144
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000bf2:	f8c3 812c 	str.w	r8, [r3, #300]	; 0x12c
 8000bf6:	f8c3 c0fc 	str.w	ip, [r3, #252]	; 0xfc
 8000bfa:	f8c3 e11c 	str.w	lr, [r3, #284]	; 0x11c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000bfe:	f883 7130 	strb.w	r7, [r3, #304]	; 0x130
 8000c02:	f8c3 1138 	str.w	r1, [r3, #312]	; 0x138
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000c06:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
  tqp->prev = (thread_t *)tqp;
 8000c0a:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 8000c0e:	f7ff fc2f 	bl	8000470 <chSchWakeupS.constprop.33>
 8000c12:	f384 8811 	msr	BASEPRI, r4
 8000c16:	f38b 8811 	msr	BASEPRI, fp
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000c1a:	7a2b      	ldrb	r3, [r5, #8]
 8000c1c:	454b      	cmp	r3, r9
 8000c1e:	d105      	bne.n	8000c2c <main+0x39c>
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 8000c20:	f8da 301c 	ldr.w	r3, [sl, #28]
 8000c24:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000c28:	f8ca 301c 	str.w	r3, [sl, #28]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000c2c:	6faa      	ldr	r2, [r5, #120]	; 0x78
 8000c2e:	491c      	ldr	r1, [pc, #112]	; (8000ca0 <main+0x410>)
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000c30:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000c32:	fba1 1202 	umull	r1, r2, r1, r2
 8000c36:	0b12      	lsrs	r2, r2, #12

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000c38:	f244 0e40 	movw	lr, #16448	; 0x4040
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000c3c:	2701      	movs	r7, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000c3e:	f240 142d 	movw	r4, #301	; 0x12d
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000c42:	f04f 30ff 	mov.w	r0, #4294967295

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8000c46:	2102      	movs	r1, #2
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000c48:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000c4a:	f8c3 e004 	str.w	lr, [r3, #4]
 8000c4e:	2200      	movs	r2, #0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000c50:	609f      	str	r7, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000c52:	601c      	str	r4, [r3, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000c54:	6218      	str	r0, [r3, #32]
 8000c56:	7229      	strb	r1, [r5, #8]
 8000c58:	f382 8811 	msr	BASEPRI, r2
 8000c5c:	2320      	movs	r3, #32
 8000c5e:	e043      	b.n	8000ce8 <main+0x458>
 8000c60:	40020000 	.word	0x40020000
 8000c64:	40020400 	.word	0x40020400
 8000c68:	20000888 	.word	0x20000888
 8000c6c:	48001400 	.word	0x48001400
 8000c70:	48001800 	.word	0x48001800
 8000c74:	48001c00 	.word	0x48001c00
 8000c78:	65555105 	.word	0x65555105
 8000c7c:	20000d28 	.word	0x20000d28
 8000c80:	40004400 	.word	0x40004400
 8000c84:	0112a880 	.word	0x0112a880
 8000c88:	20000904 	.word	0x20000904
 8000c8c:	e000e010 	.word	0xe000e010
 8000c90:	0001193f 	.word	0x0001193f
 8000c94:	05fa0300 	.word	0x05fa0300
 8000c98:	e0001000 	.word	0xe0001000
 8000c9c:	20000d48 	.word	0x20000d48
 8000ca0:	1b4e81b5 	.word	0x1b4e81b5
 8000ca4:	40021000 	.word	0x40021000
 8000ca8:	40010000 	.word	0x40010000
 8000cac:	48000400 	.word	0x48000400
 8000cb0:	48000800 	.word	0x48000800
 8000cb4:	48000c00 	.word	0x48000c00
 8000cb8:	48001000 	.word	0x48001000
 8000cbc:	280004a0 	.word	0x280004a0
 8000cc0:	51555555 	.word	0x51555555
 8000cc4:	08001a6c 	.word	0x08001a6c
 8000cc8:	e000e100 	.word	0xe000e100
 8000ccc:	08001041 	.word	0x08001041
 8000cd0:	080019a4 	.word	0x080019a4
 8000cd4:	e000ed00 	.word	0xe000ed00
 8000cd8:	40004800 	.word	0x40004800
 8000cdc:	e000edf0 	.word	0xe000edf0
 8000ce0:	08001051 	.word	0x08001051
 8000ce4:	080001b9 	.word	0x080001b9
 8000ce8:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {

  if (uartp->state == UART_STOP) {
 8000cec:	7833      	ldrb	r3, [r6, #0]

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
 8000cee:	4a7f      	ldr	r2, [pc, #508]	; (8000eec <main+0x65c>)
 8000cf0:	6072      	str	r2, [r6, #4]
 8000cf2:	42bb      	cmp	r3, r7
 8000cf4:	4c7e      	ldr	r4, [pc, #504]	; (8000ef0 <main+0x660>)
 8000cf6:	f000 809d 	beq.w	8000e34 <main+0x5a4>
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8000cfa:	6971      	ldr	r1, [r6, #20]
  dmaStreamDisable(uartp->dmatx);
 8000cfc:	69b5      	ldr	r5, [r6, #24]
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8000cfe:	684a      	ldr	r2, [r1, #4]
 8000d00:	f8d1 e000 	ldr.w	lr, [r1]
 8000d04:	6810      	ldr	r0, [r2, #0]
  dmaStreamDisable(uartp->dmatx);
 8000d06:	686f      	ldr	r7, [r5, #4]
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_start(UARTDriver *uartp) {
  uint32_t cr1;
  USART_TypeDef *u = uartp->usart;
 8000d08:	68b3      	ldr	r3, [r6, #8]
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
 8000d0a:	f8d5 9000 	ldr.w	r9, [r5]
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
    uartp->rxbuf = 0;
  }

  uartp->rxstate = UART_RX_IDLE;
 8000d0e:	2400      	movs	r4, #0
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8000d10:	f020 000f 	bic.w	r0, r0, #15
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
    uartp->rxbuf = 0;
  }

  uartp->rxstate = UART_RX_IDLE;
 8000d14:	70b4      	strb	r4, [r6, #2]
  uartp->txstate = UART_TX_IDLE;
 8000d16:	7074      	strb	r4, [r6, #1]
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8000d18:	6010      	str	r0, [r2, #0]
 8000d1a:	7c09      	ldrb	r1, [r1, #16]

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(uartp->clock / uartp->config->speed);
 8000d1c:	6870      	ldr	r0, [r6, #4]
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
 8000d1e:	f04f 080f 	mov.w	r8, #15
 8000d22:	fa08 f101 	lsl.w	r1, r8, r1
 8000d26:	f8ce 1004 	str.w	r1, [lr, #4]
  dmaStreamDisable(uartp->dmatx);
 8000d2a:	6839      	ldr	r1, [r7, #0]
 8000d2c:	f021 010f 	bic.w	r1, r1, #15
 8000d30:	6039      	str	r1, [r7, #0]
 8000d32:	f895 e010 	ldrb.w	lr, [r5, #16]
  u->ICR = 0xFFFFFFFFU;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8000d36:	6a05      	ldr	r5, [r0, #32]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 8000d38:	6981      	ldr	r1, [r0, #24]
  /* Resetting eventual pending status flags.*/
  u->ICR = 0xFFFFFFFFU;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8000d3a:	69c7      	ldr	r7, [r0, #28]
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8000d3c:	f045 0cc1 	orr.w	ip, r5, #193	; 0xc1
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8000d40:	68c5      	ldr	r5, [r0, #12]
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
 8000d42:	fa08 fe0e 	lsl.w	lr, r8, lr
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8000d46:	42a5      	cmp	r5, r4
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8000d48:	4d69      	ldr	r5, [pc, #420]	; (8000ef0 <main+0x660>)
 */
static void usart_stop(UARTDriver *uartp) {

  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
 8000d4a:	f8c9 e004 	str.w	lr, [r9, #4]
  /* Resetting eventual pending status flags.*/
  u->ICR = 0xFFFFFFFFU;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8000d4e:	f047 0740 	orr.w	r7, r7, #64	; 0x40

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(uartp->clock / uartp->config->speed);
 8000d52:	f8d0 e014 	ldr.w	lr, [r0, #20]
  /* Stops RX and TX DMA channels.*/
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
 8000d56:	601c      	str	r4, [r3, #0]

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(uartp->clock / uartp->config->speed);
 8000d58:	68f0      	ldr	r0, [r6, #12]
  dmaStreamDisable(uartp->dmarx);
  dmaStreamDisable(uartp->dmatx);
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
  uartp->usart->CR2 = 0;
 8000d5a:	605c      	str	r4, [r3, #4]

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(uartp->clock / uartp->config->speed);
 8000d5c:	fbb0 f0fe 	udiv	r0, r0, lr
  dmaStreamDisable(uartp->dmatx);
  
  /* Stops USART operations.*/
  uartp->usart->CR1 = 0;
  uartp->usart->CR2 = 0;
  uartp->usart->CR3 = 0;
 8000d60:	609c      	str	r4, [r3, #8]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 8000d62:	f441 7186 	orr.w	r1, r1, #268	; 0x10c

  /* Defensive programming, starting from a clean state.*/
  usart_stop(uartp);

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(uartp->clock / uartp->config->speed);
 8000d66:	60d8      	str	r0, [r3, #12]

  /* Resetting eventual pending status flags.*/
  u->ICR = 0xFFFFFFFFU;
 8000d68:	f04f 30ff 	mov.w	r0, #4294967295
 8000d6c:	6218      	str	r0, [r3, #32]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 8000d6e:	f041 0101 	orr.w	r1, r1, #1
  /* Resetting eventual pending status flags.*/
  u->ICR = 0xFFFFFFFFU;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
 8000d72:	605f      	str	r7, [r3, #4]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8000d74:	f105 071c 	add.w	r7, r5, #28
  u->ICR = 0xFFFFFFFFU;

  /* Note that some bits are enforced because required for correct driver
     operations.*/
  u->CR2 = uartp->config->cr2 | USART_CR2_LBDIE;
  u->CR3 = uartp->config->cr3 | USART_CR3_DMAT | USART_CR3_DMAR |
 8000d78:	f8c3 c008 	str.w	ip, [r3, #8]
                                USART_CR3_EIE;

  /* Mustn't ever set TCIE here - if done, it causes an immediate
     interrupt.*/
  cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
  u->CR1 = uartp->config->cr1 | cr1;
 8000d7c:	6019      	str	r1, [r3, #0]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8000d7e:	60d7      	str	r7, [r2, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8000d80:	6933      	ldr	r3, [r6, #16]
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8000d82:	bf14      	ite	ne
 8000d84:	2022      	movne	r0, #34	; 0x22
 8000d86:	2020      	moveq	r0, #32
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8000d88:	4303      	orrs	r3, r0
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8000d8a:	2101      	movs	r1, #1
 8000d8c:	6051      	str	r1, [r2, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8000d8e:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(uartp->dmarx);
 8000d90:	6813      	ldr	r3, [r2, #0]
  uart_lld_start(uartp);
  uartp->state = UART_READY;
 8000d92:	2102      	movs	r1, #2
 8000d94:	f043 0301 	orr.w	r3, r3, #1
 8000d98:	6013      	str	r3, [r2, #0]
 8000d9a:	7031      	strb	r1, [r6, #0]
 8000d9c:	f384 8811 	msr	BASEPRI, r4
     * Activates the serial driver 2 using the driver default configuration.
     */
  sdStart(&SD2, &cs_Serial2Config);
  uartStart(&UARTD3, &uartcfg);

  palSetPadMode(GPIOC, 10, PAL_MODE_ALTERNATE(7));	/* USART3_TX */
 8000da0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000da4:	f7ff faa4 	bl	80002f0 <_pal_lld_setgroupmode.constprop.19>
  palSetPadMode(GPIOC, 11, PAL_MODE_ALTERNATE(7));	/* USART3_RX */
 8000da8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000dac:	f7ff faa0 	bl	80002f0 <_pal_lld_setgroupmode.constprop.19>

  rbi_LedStatus = FALSE;
 8000db0:	4a50      	ldr	r2, [pc, #320]	; (8000ef4 <main+0x664>)
  rub_LedTimeout = 0;
 8000db2:	4b51      	ldr	r3, [pc, #324]	; (8000ef8 <main+0x668>)
  uartStart(&UARTD3, &uartcfg);

  palSetPadMode(GPIOC, 10, PAL_MODE_ALTERNATE(7));	/* USART3_TX */
  palSetPadMode(GPIOC, 11, PAL_MODE_ALTERNATE(7));	/* USART3_RX */

  rbi_LedStatus = FALSE;
 8000db4:	7014      	strb	r4, [r2, #0]
  rub_LedTimeout = 0;
 8000db6:	701c      	strb	r4, [r3, #0]
 8000db8:	2320      	movs	r3, #32
 8000dba:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(uartp != NULL);

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
 8000dbe:	78b2      	ldrb	r2, [r6, #2]
 8000dc0:	2a01      	cmp	r2, #1
 8000dc2:	d06e      	beq.n	8000ea2 <main+0x612>
 8000dc4:	2300      	movs	r3, #0
 8000dc6:	f383 8811 	msr	BASEPRI, r3
 8000dca:	2220      	movs	r2, #32
 8000dcc:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(uartp != NULL);

  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->txstate == UART_TX_ACTIVE) {
 8000dd0:	7872      	ldrb	r2, [r6, #1]
 8000dd2:	4947      	ldr	r1, [pc, #284]	; (8000ef0 <main+0x660>)
 8000dd4:	2a01      	cmp	r2, #1
 8000dd6:	d056      	beq.n	8000e86 <main+0x5f6>
 8000dd8:	2400      	movs	r4, #0
 8000dda:	f384 8811 	msr	BASEPRI, r4
 8000dde:	2320      	movs	r3, #32
 8000de0:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {

  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);
 8000de4:	6971      	ldr	r1, [r6, #20]

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, n);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
 8000de6:	6932      	ldr	r2, [r6, #16]
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {

  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);
 8000de8:	684b      	ldr	r3, [r1, #4]
 8000dea:	680f      	ldr	r7, [r1, #0]
 8000dec:	6818      	ldr	r0, [r3, #0]

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
 8000dee:	4d43      	ldr	r5, [pc, #268]	; (8000efc <main+0x66c>)
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {

  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);
 8000df0:	f020 000f 	bic.w	r0, r0, #15
 8000df4:	6018      	str	r0, [r3, #0]
 8000df6:	7c08      	ldrb	r0, [r1, #16]
 8000df8:	210f      	movs	r1, #15
 8000dfa:	4081      	lsls	r1, r0

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, n);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
 8000dfc:	f042 0282 	orr.w	r2, r2, #130	; 0x82
  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, n);
 8000e00:	2040      	movs	r0, #64	; 0x40
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {

  /* Stopping previous activity (idle state).*/
  dmaStreamDisable(uartp->dmarx);
 8000e02:	6079      	str	r1, [r7, #4]

  /* RX DMA channel preparation.*/
  dmaStreamSetMemory0(uartp->dmarx, rxbuf);
 8000e04:	60dd      	str	r5, [r3, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, n);
 8000e06:	6058      	str	r0, [r3, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
 8000e08:	601a      	str	r2, [r3, #0]
                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);

  /* Starting transfer.*/
  dmaStreamEnable(uartp->dmarx);
 8000e0a:	681a      	ldr	r2, [r3, #0]
  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");

  uart_lld_start_receive(uartp, n, rxbuf);
  uartp->rxstate = UART_RX_ACTIVE;
 8000e0c:	2101      	movs	r1, #1
 8000e0e:	430a      	orrs	r2, r1
 8000e10:	601a      	str	r2, [r3, #0]
 8000e12:	70b1      	strb	r1, [r6, #2]
 8000e14:	f384 8811 	msr	BASEPRI, r4
  uartStartReceive(&UARTD3, 64, buffer);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(pool_Task_50ms, sizeof(pool_Task_50ms), NORMALPRIO, Task_50ms, NULL);
 8000e18:	4939      	ldr	r1, [pc, #228]	; (8000f00 <main+0x670>)
 8000e1a:	483a      	ldr	r0, [pc, #232]	; (8000f04 <main+0x674>)
 8000e1c:	f7ff fb58 	bl	80004d0 <chThdCreateStatic.constprop.28>
  chThdCreateStatic(pool_Task_5ms, sizeof(pool_Task_5ms), NORMALPRIO, Task_5ms, NULL);
 8000e20:	4939      	ldr	r1, [pc, #228]	; (8000f08 <main+0x678>)
 8000e22:	483a      	ldr	r0, [pc, #232]	; (8000f0c <main+0x67c>)
 8000e24:	f7ff fb54 	bl	80004d0 <chThdCreateStatic.constprop.28>

  chThdExit(0);
 8000e28:	4620      	mov	r0, r4
 8000e2a:	f000 fbd1 	bl	80015d0 <chThdExit>
}
 8000e2e:	b009      	add	sp, #36	; 0x24
 8000e30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif

#if STM32_UART_USE_USART3
    if (&UARTD3 == uartp) {
      bool b;
      b = dmaStreamAllocate(uartp->dmarx,
 8000e34:	4936      	ldr	r1, [pc, #216]	; (8000f10 <main+0x680>)
      b = dmaStreamAllocate(uartp->dmatx,
                            STM32_UART_USART3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableUSART3(FALSE);
 8000e36:	4d37      	ldr	r5, [pc, #220]	; (8000f14 <main+0x684>)
#endif

#if STM32_UART_USE_USART3
    if (&UARTD3 == uartp) {
      bool b;
      b = dmaStreamAllocate(uartp->dmarx,
 8000e38:	6960      	ldr	r0, [r4, #20]
 8000e3a:	f7ff faa9 	bl	8000390 <dmaStreamAllocate.constprop.9>
                            STM32_UART_USART3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_rx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(uartp->dmatx,
 8000e3e:	4936      	ldr	r1, [pc, #216]	; (8000f18 <main+0x688>)
 8000e40:	69a0      	ldr	r0, [r4, #24]
 8000e42:	f7ff faa5 	bl	8000390 <dmaStreamAllocate.constprop.9>
                            STM32_UART_USART3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableUSART3(FALSE);
 8000e46:	69e9      	ldr	r1, [r5, #28]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000e48:	4a34      	ldr	r2, [pc, #208]	; (8000f1c <main+0x68c>)
    }
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
 8000e4a:	6860      	ldr	r0, [r4, #4]
 8000e4c:	4b34      	ldr	r3, [pc, #208]	; (8000f20 <main+0x690>)
      b = dmaStreamAllocate(uartp->dmatx,
                            STM32_UART_USART3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)uart_lld_serve_tx_end_irq,
                            (void *)uartp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableUSART3(FALSE);
 8000e4e:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 8000e52:	61e9      	str	r1, [r5, #28]
 8000e54:	27c0      	movs	r7, #192	; 0xc0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000e56:	2180      	movs	r1, #128	; 0x80

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000e58:	f882 7327 	strb.w	r7, [r2, #807]	; 0x327
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000e5c:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000e60:	6051      	str	r1, [r2, #4]
    }
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
 8000e62:	6982      	ldr	r2, [r0, #24]
 8000e64:	4013      	ands	r3, r2
 8000e66:	f1b3 2f10 	cmp.w	r3, #268439552	; 0x10001000
 8000e6a:	d03a      	beq.n	8000ee2 <main+0x652>
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
 8000e6c:	6971      	ldr	r1, [r6, #20]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
 8000e6e:	69b2      	ldr	r2, [r6, #24]

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
 8000e70:	68b3      	ldr	r3, [r6, #8]
 8000e72:	6848      	ldr	r0, [r1, #4]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
 8000e74:	6851      	ldr	r1, [r2, #4]

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
 8000e76:	f103 0424 	add.w	r4, r3, #36	; 0x24
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
    uartp->rxbuf = 0;
 8000e7a:	2200      	movs	r2, #0
    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
 8000e7c:	3328      	adds	r3, #40	; 0x28

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
 8000e7e:	6084      	str	r4, [r0, #8]
    dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
 8000e80:	608b      	str	r3, [r1, #8]
    uartp->rxbuf = 0;
 8000e82:	83b2      	strh	r2, [r6, #28]
 8000e84:	e739      	b.n	8000cfa <main+0x46a>
 *
 * @notapi
 */
size_t uart_lld_stop_send(UARTDriver *uartp) {

  dmaStreamDisable(uartp->dmatx);
 8000e86:	6988      	ldr	r0, [r1, #24]
 8000e88:	6842      	ldr	r2, [r0, #4]
 8000e8a:	6805      	ldr	r5, [r0, #0]
 8000e8c:	6814      	ldr	r4, [r2, #0]
 8000e8e:	f024 040f 	bic.w	r4, r4, #15
 8000e92:	6014      	str	r4, [r2, #0]
 8000e94:	7c00      	ldrb	r0, [r0, #16]
  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->txstate == UART_TX_ACTIVE) {
    n = uart_lld_stop_send(uartp);
    uartp->txstate = UART_TX_IDLE;
 8000e96:	704b      	strb	r3, [r1, #1]
 8000e98:	230f      	movs	r3, #15
 8000e9a:	4083      	lsls	r3, r0
 8000e9c:	606b      	str	r3, [r5, #4]

  return dmaStreamGetTransactionSize(uartp->dmatx);
 8000e9e:	6853      	ldr	r3, [r2, #4]
 8000ea0:	e79a      	b.n	8000dd8 <main+0x548>
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 8000ea2:	6968      	ldr	r0, [r5, #20]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8000ea4:	686b      	ldr	r3, [r5, #4]
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 8000ea6:	6841      	ldr	r1, [r0, #4]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8000ea8:	68dd      	ldr	r5, [r3, #12]
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 8000eaa:	680b      	ldr	r3, [r1, #0]
 8000eac:	f8d0 e000 	ldr.w	lr, [r0]
 8000eb0:	f023 030f 	bic.w	r3, r3, #15
 8000eb4:	600b      	str	r3, [r1, #0]
 8000eb6:	7c03      	ldrb	r3, [r0, #16]
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8000eb8:	6930      	ldr	r0, [r6, #16]
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8000eba:	42a5      	cmp	r5, r4
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 8000ebc:	fa08 f303 	lsl.w	r3, r8, r3
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 8000ec0:	bf14      	ite	ne
 8000ec2:	2522      	movne	r5, #34	; 0x22
 8000ec4:	2520      	moveq	r5, #32
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
 8000ec6:	f8ce 3004 	str.w	r3, [lr, #4]
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8000eca:	ea45 0300 	orr.w	r3, r5, r0
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
  size_t n;

  dmaStreamDisable(uartp->dmarx);
  n = dmaStreamGetTransactionSize(uartp->dmarx);
 8000ece:	6848      	ldr	r0, [r1, #4]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8000ed0:	60cf      	str	r7, [r1, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8000ed2:	604a      	str	r2, [r1, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8000ed4:	600b      	str	r3, [r1, #0]
  dmaStreamEnable(uartp->dmarx);
 8000ed6:	680b      	ldr	r3, [r1, #0]
 8000ed8:	f043 0301 	orr.w	r3, r3, #1
 8000edc:	600b      	str	r3, [r1, #0]
  osalSysLock();
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
    n = uart_lld_stop_receive(uartp);
    uartp->rxstate = UART_RX_IDLE;
 8000ede:	70b4      	strb	r4, [r6, #2]
 8000ee0:	e770      	b.n	8000dc4 <main+0x534>
#endif

    /* Static DMA setup, the transfer size depends on the USART settings,
       it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
      uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8000ee2:	6923      	ldr	r3, [r4, #16]
 8000ee4:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 8000ee8:	6123      	str	r3, [r4, #16]
 8000eea:	e7bf      	b.n	8000e6c <main+0x5dc>
 8000eec:	20000800 	.word	0x20000800
 8000ef0:	20000d28 	.word	0x20000d28
 8000ef4:	20000960 	.word	0x20000960
 8000ef8:	20000e98 	.word	0x20000e98
 8000efc:	20000b28 	.word	0x20000b28
 8000f00:	08000781 	.word	0x08000781
 8000f04:	20000b68 	.word	0x20000b68
 8000f08:	080007b1 	.word	0x080007b1
 8000f0c:	20000968 	.word	0x20000968
 8000f10:	08000fb1 	.word	0x08000fb1
 8000f14:	40021000 	.word	0x40021000
 8000f18:	08000f61 	.word	0x08000f61
 8000f1c:	e000e100 	.word	0xe000e100
 8000f20:	10001400 	.word	0x10001400
	...

08000f30 <rxerr.lto_priv.41>:

/*
 * This callback is invoked on a receive error, the errors mask is passed
 * as parameter.
 */
static void rxerr(UARTDriver *uartp, uartflags_t e) {
 8000f30:	4770      	bx	lr
 8000f32:	bf00      	nop
	...

08000f40 <txend1.lto_priv.39>:

/*
 * This callback is invoked when a transmission buffer has been completely
 * read by the driver.
 */
static void txend1(UARTDriver *uartp) {
 8000f40:	4770      	bx	lr
 8000f42:	bf00      	nop
	...

08000f50 <txend2.lto_priv.40>:
 8000f50:	4770      	bx	lr
 8000f52:	bf00      	nop
	...

08000f60 <uart_lld_serve_tx_end_irq.lto_priv.37>:
 */
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000f60:	070b      	lsls	r3, r1, #28
 8000f62:	d416      	bmi.n	8000f92 <uart_lld_serve_tx_end_irq.lto_priv.37+0x32>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8000f64:	6983      	ldr	r3, [r0, #24]

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8000f66:	6841      	ldr	r1, [r0, #4]
 * @brief   TX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_tx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8000f68:	b570      	push	{r4, r5, r6, lr}
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8000f6a:	685d      	ldr	r5, [r3, #4]
 8000f6c:	681e      	ldr	r6, [r3, #0]
 8000f6e:	682a      	ldr	r2, [r5, #0]

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8000f70:	6809      	ldr	r1, [r1, #0]
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8000f72:	f022 020f 	bic.w	r2, r2, #15
 8000f76:	602a      	str	r2, [r5, #0]
 8000f78:	7c1a      	ldrb	r2, [r3, #16]
 8000f7a:	230f      	movs	r3, #15
 8000f7c:	4093      	lsls	r3, r2

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8000f7e:	2202      	movs	r2, #2
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(uartp->dmatx);
 8000f80:	6073      	str	r3, [r6, #4]
 8000f82:	4604      	mov	r4, r0

  /* A callback is generated, if enabled, after a completed transfer.*/
  _uart_tx1_isr_code(uartp);
 8000f84:	7042      	strb	r2, [r0, #1]
 8000f86:	b149      	cbz	r1, 8000f9c <uart_lld_serve_tx_end_irq.lto_priv.37+0x3c>
 8000f88:	4788      	blx	r1
 8000f8a:	7863      	ldrb	r3, [r4, #1]
 8000f8c:	2b02      	cmp	r3, #2
 8000f8e:	d005      	beq.n	8000f9c <uart_lld_serve_tx_end_irq.lto_priv.37+0x3c>
 8000f90:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f92:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000f94:	4b03      	ldr	r3, [pc, #12]	; (8000fa4 <uart_lld_serve_tx_end_irq.lto_priv.37+0x44>)
 8000f96:	4a04      	ldr	r2, [pc, #16]	; (8000fa8 <uart_lld_serve_tx_end_irq.lto_priv.37+0x48>)
 8000f98:	625a      	str	r2, [r3, #36]	; 0x24
 8000f9a:	e7fe      	b.n	8000f9a <uart_lld_serve_tx_end_irq.lto_priv.37+0x3a>
 8000f9c:	2300      	movs	r3, #0
 8000f9e:	7063      	strb	r3, [r4, #1]
 8000fa0:	bd70      	pop	{r4, r5, r6, pc}
 8000fa2:	bf00      	nop
 8000fa4:	20000904 	.word	0x20000904
 8000fa8:	08001a8c 	.word	0x08001a8c
 8000fac:	00000000 	.word	0x00000000

08000fb0 <uart_lld_serve_rx_end_irq.lto_priv.36>:
 */
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_UART_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000fb0:	070b      	lsls	r3, r1, #28
 8000fb2:	d40d      	bmi.n	8000fd0 <uart_lld_serve_rx_end_irq.lto_priv.36+0x20>
  }
#else
  (void)flags;
#endif

  if (uartp->rxstate == UART_RX_IDLE) {
 8000fb4:	7883      	ldrb	r3, [r0, #2]
 * @brief   RX DMA common service routine.
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void uart_lld_serve_rx_end_irq(UARTDriver *uartp, uint32_t flags) {
 8000fb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000fba:	4604      	mov	r4, r0
  }
#else
  (void)flags;
#endif

  if (uartp->rxstate == UART_RX_IDLE) {
 8000fbc:	b96b      	cbnz	r3, 8000fda <uart_lld_serve_rx_end_irq.lto_priv.36+0x2a>
    /* Receiver in idle state, a callback is generated, if enabled, for each
       received character and then the driver stays in the same state.*/
    _uart_rx_idle_code(uartp);
 8000fbe:	6843      	ldr	r3, [r0, #4]
 8000fc0:	68db      	ldr	r3, [r3, #12]
 8000fc2:	2b00      	cmp	r3, #0
 8000fc4:	d032      	beq.n	800102c <uart_lld_serve_rx_end_irq.lto_priv.36+0x7c>
 8000fc6:	8b81      	ldrh	r1, [r0, #28]
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
    _uart_rx_complete_isr_code(uartp);
  }
}
 8000fc8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
#endif

  if (uartp->rxstate == UART_RX_IDLE) {
    /* Receiver in idle state, a callback is generated, if enabled, for each
       received character and then the driver stays in the same state.*/
    _uart_rx_idle_code(uartp);
 8000fcc:	b289      	uxth	r1, r1
 8000fce:	4718      	bx	r3
 8000fd0:	b672      	cpsid	i
 8000fd2:	4b17      	ldr	r3, [pc, #92]	; (8001030 <uart_lld_serve_rx_end_irq.lto_priv.36+0x80>)
 8000fd4:	4a17      	ldr	r2, [pc, #92]	; (8001034 <uart_lld_serve_rx_end_irq.lto_priv.36+0x84>)
 8000fd6:	625a      	str	r2, [r3, #36]	; 0x24
 8000fd8:	e7fe      	b.n	8000fd8 <uart_lld_serve_rx_end_irq.lto_priv.36+0x28>
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8000fda:	6941      	ldr	r1, [r0, #20]
    _uart_rx_complete_isr_code(uartp);
 8000fdc:	6842      	ldr	r2, [r0, #4]
    _uart_rx_idle_code(uartp);
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8000fde:	684b      	ldr	r3, [r1, #4]
 8000fe0:	680f      	ldr	r7, [r1, #0]
 8000fe2:	681d      	ldr	r5, [r3, #0]
    _uart_rx_complete_isr_code(uartp);
 8000fe4:	6896      	ldr	r6, [r2, #8]
    _uart_rx_idle_code(uartp);
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8000fe6:	f025 050f 	bic.w	r5, r5, #15
 8000fea:	601d      	str	r5, [r3, #0]
 8000fec:	7c0d      	ldrb	r5, [r1, #16]
 8000fee:	210f      	movs	r1, #15
 8000ff0:	40a9      	lsls	r1, r5
    _uart_rx_complete_isr_code(uartp);
 8000ff2:	2502      	movs	r5, #2
    _uart_rx_idle_code(uartp);
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
 8000ff4:	6079      	str	r1, [r7, #4]
    _uart_rx_complete_isr_code(uartp);
 8000ff6:	7085      	strb	r5, [r0, #2]
 8000ff8:	b136      	cbz	r6, 8001008 <uart_lld_serve_rx_end_irq.lto_priv.36+0x58>
 8000ffa:	47b0      	blx	r6
 8000ffc:	78a3      	ldrb	r3, [r4, #2]
 8000ffe:	42ab      	cmp	r3, r5
 8001000:	d114      	bne.n	800102c <uart_lld_serve_rx_end_irq.lto_priv.36+0x7c>
 8001002:	6963      	ldr	r3, [r4, #20]
 8001004:	6862      	ldr	r2, [r4, #4]
 8001006:	685b      	ldr	r3, [r3, #4]
static void uart_enter_rx_idle_loop(UARTDriver *uartp) {
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
 8001008:	68d1      	ldr	r1, [r2, #12]
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 800100a:	6922      	ldr	r2, [r4, #16]
  uint32_t mode;
  
  /* RX DMA channel preparation, if the char callback is defined then the
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
 800100c:	2900      	cmp	r1, #0
 800100e:	bf14      	ite	ne
 8001010:	2122      	movne	r1, #34	; 0x22
 8001012:	2120      	moveq	r1, #32
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8001014:	430a      	orrs	r2, r1
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
    _uart_rx_complete_isr_code(uartp);
 8001016:	2500      	movs	r5, #0
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8001018:	2101      	movs	r1, #1
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 800101a:	f104 001c 	add.w	r0, r4, #28
  }
  else {
    /* Receiver in active state, a callback is generated, if enabled, after
       a completed transfer.*/
    dmaStreamDisable(uartp->dmarx);
    _uart_rx_complete_isr_code(uartp);
 800101e:	70a5      	strb	r5, [r4, #2]
     TCIE interrupt is enabled too.*/
  if (uartp->config->rxchar_cb == NULL)
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC;
  else
    mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_CIRC | STM32_DMA_CR_TCIE;
  dmaStreamSetMemory0(uartp->dmarx, &uartp->rxbuf);
 8001020:	60d8      	str	r0, [r3, #12]
  dmaStreamSetTransactionSize(uartp->dmarx, 1);
 8001022:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
 8001024:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(uartp->dmarx);
 8001026:	681a      	ldr	r2, [r3, #0]
 8001028:	430a      	orrs	r2, r1
 800102a:	601a      	str	r2, [r3, #0]
 800102c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001030:	20000904 	.word	0x20000904
 8001034:	08001a8c 	.word	0x08001a8c
	...

08001040 <notify2.lto_priv.38>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8001040:	4a02      	ldr	r2, [pc, #8]	; (800104c <notify2.lto_priv.38+0xc>)
 8001042:	6813      	ldr	r3, [r2, #0]
 8001044:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001048:	6013      	str	r3, [r2, #0]
 800104a:	4770      	bx	lr
 800104c:	40004400 	.word	0x40004400

08001050 <_idle_thread.lto_priv.42>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001050:	e7fe      	b.n	8001050 <_idle_thread.lto_priv.42>
 8001052:	bf00      	nop
	...

08001060 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001060:	b410      	push	{r4}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001062:	2320      	movs	r3, #32
 8001064:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8001068:	7c03      	ldrb	r3, [r0, #16]
 800106a:	2b07      	cmp	r3, #7
 800106c:	d80e      	bhi.n	800108c <wakeup+0x2c>
 800106e:	e8df f003 	tbb	[pc, r3]
 8001072:	0d27      	.short	0x0d27
 8001074:	0408230d 	.word	0x0408230d
 8001078:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800107a:	6942      	ldr	r2, [r0, #20]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800107c:	6893      	ldr	r3, [r2, #8]
 800107e:	3301      	adds	r3, #1
 8001080:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001082:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001086:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001088:	6802      	ldr	r2, [r0, #0]
 800108a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800108c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001090:	2200      	movs	r2, #0
 8001092:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8001094:	4b0d      	ldr	r3, [pc, #52]	; (80010cc <wakeup+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001096:	6144      	str	r4, [r0, #20]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001098:	7402      	strb	r2, [r0, #16]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800109a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800109c:	689a      	ldr	r2, [r3, #8]
 800109e:	428a      	cmp	r2, r1
 80010a0:	d2fb      	bcs.n	800109a <wakeup+0x3a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80010a2:	685a      	ldr	r2, [r3, #4]
 80010a4:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80010a6:	6003      	str	r3, [r0, #0]
 80010a8:	2100      	movs	r1, #0
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80010aa:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80010ac:	6058      	str	r0, [r3, #4]
 80010ae:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80010b2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80010b6:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80010b8:	6943      	ldr	r3, [r0, #20]
 80010ba:	2200      	movs	r2, #0
 80010bc:	601a      	str	r2, [r3, #0]
 80010be:	e7e5      	b.n	800108c <wakeup+0x2c>
 80010c0:	2300      	movs	r3, #0
 80010c2:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80010c6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80010ca:	4770      	bx	lr
 80010cc:	20000904 	.word	0x20000904

080010d0 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 80010d0:	4a06      	ldr	r2, [pc, #24]	; (80010ec <SVC_Handler+0x1c>)
 80010d2:	6853      	ldr	r3, [r2, #4]
 80010d4:	f023 0301 	bic.w	r3, r3, #1
 80010d8:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80010da:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80010de:	3368      	adds	r3, #104	; 0x68
 80010e0:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80010e4:	2300      	movs	r3, #0
 80010e6:	f383 8811 	msr	BASEPRI, r3
 80010ea:	4770      	bx	lr
 80010ec:	e000ef30 	.word	0xe000ef30

080010f0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80010f0:	4b07      	ldr	r3, [pc, #28]	; (8001110 <chSchGoSleepS+0x20>)
 80010f2:	6919      	ldr	r1, [r3, #16]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80010f4:	681a      	ldr	r2, [r3, #0]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80010f6:	b410      	push	{r4}
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80010f8:	7408      	strb	r0, [r1, #16]

  tqp->next             = tp->queue.next;
 80010fa:	6810      	ldr	r0, [r2, #0]
 80010fc:	6018      	str	r0, [r3, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80010fe:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8001100:	6043      	str	r3, [r0, #4]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001102:	611a      	str	r2, [r3, #16]
  currp->state = CH_STATE_CURRENT;
 8001104:	7414      	strb	r4, [r2, #16]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001106:	4610      	mov	r0, r2
}
 8001108:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800110c:	f7ff b848 	b.w	80001a0 <_port_switch>
 8001110:	20000904 	.word	0x20000904
	...

08001120 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001120:	b4f0      	push	{r4, r5, r6, r7}
 8001122:	4e14      	ldr	r6, [pc, #80]	; (8001174 <__init_ram_areas+0x54>)
 8001124:	4d14      	ldr	r5, [pc, #80]	; (8001178 <__init_ram_areas+0x58>)
 8001126:	4c15      	ldr	r4, [pc, #84]	; (800117c <__init_ram_areas+0x5c>)
 8001128:	4b15      	ldr	r3, [pc, #84]	; (8001180 <__init_ram_areas+0x60>)
 800112a:	4916      	ldr	r1, [pc, #88]	; (8001184 <__init_ram_areas+0x64>)
 800112c:	f106 0770 	add.w	r7, r6, #112	; 0x70
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001130:	429c      	cmp	r4, r3
 8001132:	d912      	bls.n	800115a <__init_ram_areas+0x3a>
 8001134:	3904      	subs	r1, #4
 8001136:	461a      	mov	r2, r3
      *p = *tp;
 8001138:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800113c:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001140:	4294      	cmp	r4, r2
 8001142:	d8f9      	bhi.n	8001138 <__init_ram_areas+0x18>
 8001144:	43da      	mvns	r2, r3
 8001146:	4414      	add	r4, r2
 8001148:	f024 0403 	bic.w	r4, r4, #3
 800114c:	3404      	adds	r4, #4
 800114e:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001150:	429d      	cmp	r5, r3
 8001152:	d904      	bls.n	800115e <__init_ram_areas+0x3e>
      *p = 0;
 8001154:	2200      	movs	r2, #0
 8001156:	f843 2b04 	str.w	r2, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800115a:	429d      	cmp	r5, r3
 800115c:	d8fa      	bhi.n	8001154 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800115e:	42be      	cmp	r6, r7
 8001160:	d005      	beq.n	800116e <__init_ram_areas+0x4e>
 8001162:	6931      	ldr	r1, [r6, #16]
 8001164:	6973      	ldr	r3, [r6, #20]
 8001166:	69b4      	ldr	r4, [r6, #24]
 8001168:	69f5      	ldr	r5, [r6, #28]
 800116a:	3610      	adds	r6, #16
 800116c:	e7e0      	b.n	8001130 <__init_ram_areas+0x10>
#endif
}
 800116e:	bcf0      	pop	{r4, r5, r6, r7}
 8001170:	4770      	bx	lr
 8001172:	bf00      	nop
 8001174:	08001a98 	.word	0x08001a98
 8001178:	20000ea0 	.word	0x20000ea0
 800117c:	20000ea0 	.word	0x20000ea0
 8001180:	20000ea0 	.word	0x20000ea0
 8001184:	08001b3c 	.word	0x08001b3c
	...

08001190 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001190:	e7fe      	b.n	8001190 <__default_exit>
 8001192:	bf00      	nop
	...

080011a0 <__late_init>:
 80011a0:	4770      	bx	lr
 80011a2:	bf00      	nop
	...

080011b0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80011b0:	4770      	bx	lr
 80011b2:	bf00      	nop
	...

080011c0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80011c0:	4b0e      	ldr	r3, [pc, #56]	; (80011fc <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80011c2:	490f      	ldr	r1, [pc, #60]	; (8001200 <chTMStopMeasurementX+0x40>)
 80011c4:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80011c6:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80011c8:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80011ca:	6d8f      	ldr	r7, [r1, #88]	; 0x58
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 80011cc:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80011ce:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80011d0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80011d4:	1ad3      	subs	r3, r2, r3
 80011d6:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 80011d8:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 80011da:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80011dc:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80011de:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 80011e2:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80011e4:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 80011e8:	bf88      	it	hi
 80011ea:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 80011ec:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80011ee:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80011f0:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 80011f4:	bf38      	it	cc
 80011f6:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80011f8:	bcf0      	pop	{r4, r5, r6, r7}
 80011fa:	4770      	bx	lr
 80011fc:	e0001000 	.word	0xe0001000
 8001200:	20000904 	.word	0x20000904
	...

08001210 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8001210:	4a0d      	ldr	r2, [pc, #52]	; (8001248 <chSchDoReschedule+0x38>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8001212:	6810      	ldr	r0, [r2, #0]

  tqp->next             = tp->queue.next;
 8001214:	6803      	ldr	r3, [r0, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001216:	b410      	push	{r4}
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001218:	2101      	movs	r1, #1
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 800121a:	6914      	ldr	r4, [r2, #16]
 800121c:	6013      	str	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800121e:	605a      	str	r2, [r3, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001220:	6110      	str	r0, [r2, #16]
  currp->state = CH_STATE_CURRENT;
 8001222:	7401      	strb	r1, [r0, #16]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001224:	2200      	movs	r2, #0
 8001226:	68a1      	ldr	r1, [r4, #8]
 8001228:	7422      	strb	r2, [r4, #16]
 800122a:	e000      	b.n	800122e <chSchDoReschedule+0x1e>
 800122c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800122e:	689a      	ldr	r2, [r3, #8]
 8001230:	428a      	cmp	r2, r1
 8001232:	d8fb      	bhi.n	800122c <chSchDoReschedule+0x1c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001234:	685a      	ldr	r2, [r3, #4]
 8001236:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001238:	6023      	str	r3, [r4, #0]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800123a:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800123c:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800123e:	605c      	str	r4, [r3, #4]
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 8001240:	f85d 4b04 	ldr.w	r4, [sp], #4
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001244:	f7fe bfac 	b.w	80001a0 <_port_switch>
 8001248:	20000904 	.word	0x20000904
 800124c:	00000000 	.word	0x00000000

08001250 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001250:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001252:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001254:	b086      	sub	sp, #24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001256:	d02f      	beq.n	80012b8 <chSchGoSleepTimeoutS+0x68>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001258:	4c1b      	ldr	r4, [pc, #108]	; (80012c8 <chSchGoSleepTimeoutS+0x78>)
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
 800125a:	6963      	ldr	r3, [r4, #20]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800125c:	6925      	ldr	r5, [r4, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 800125e:	689a      	ldr	r2, [r3, #8]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8001260:	9505      	str	r5, [sp, #20]
 8001262:	4606      	mov	r6, r0
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8001264:	4291      	cmp	r1, r2

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8001266:	4819      	ldr	r0, [pc, #100]	; (80012cc <chSchGoSleepTimeoutS+0x7c>)
 8001268:	9004      	str	r0, [sp, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 800126a:	d904      	bls.n	8001276 <chSchGoSleepTimeoutS+0x26>
    delta -= p->delta;
    p = p->next;
 800126c:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
 800126e:	1a89      	subs	r1, r1, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8001270:	689a      	ldr	r2, [r3, #8]
 8001272:	428a      	cmp	r2, r1
 8001274:	d3fa      	bcc.n	800126c <chSchGoSleepTimeoutS+0x1c>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8001276:	6858      	ldr	r0, [r3, #4]
 8001278:	9002      	str	r0, [sp, #8]
  vtp->prev->next = vtp;
 800127a:	aa01      	add	r2, sp, #4
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800127c:	9301      	str	r3, [sp, #4]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 800127e:	6002      	str	r2, [r0, #0]
  p->prev = vtp;
 8001280:	605a      	str	r2, [r3, #4]
  vtp->delta = delta
 8001282:	9103      	str	r1, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8001284:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8001286:	4d10      	ldr	r5, [pc, #64]	; (80012c8 <chSchGoSleepTimeoutS+0x78>)
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8001288:	1a51      	subs	r1, r2, r1
 800128a:	6099      	str	r1, [r3, #8]
    chSchGoSleepS(newstate);
 800128c:	4630      	mov	r0, r6
  ch.vtlist.delta = (systime_t)-1;
 800128e:	f04f 36ff 	mov.w	r6, #4294967295
 8001292:	61e6      	str	r6, [r4, #28]
 8001294:	f7ff ff2c 	bl	80010f0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001298:	9b04      	ldr	r3, [sp, #16]
 800129a:	b14b      	cbz	r3, 80012b0 <chSchGoSleepTimeoutS+0x60>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
 800129c:	9b01      	ldr	r3, [sp, #4]
 800129e:	9a03      	ldr	r2, [sp, #12]
 80012a0:	6898      	ldr	r0, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
 80012a2:	9902      	ldr	r1, [sp, #8]
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
 80012a4:	4402      	add	r2, r0
 80012a6:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
 80012a8:	600b      	str	r3, [r1, #0]
  vtp->next->prev = vtp->prev;
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	6059      	str	r1, [r3, #4]
  vtp->func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
 80012ae:	61ee      	str	r6, [r5, #28]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 80012b0:	6923      	ldr	r3, [r4, #16]
}
 80012b2:	6958      	ldr	r0, [r3, #20]
 80012b4:	b006      	add	sp, #24
 80012b6:	bd70      	pop	{r4, r5, r6, pc}
 80012b8:	4c03      	ldr	r4, [pc, #12]	; (80012c8 <chSchGoSleepTimeoutS+0x78>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80012ba:	f7ff ff19 	bl	80010f0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 80012be:	6923      	ldr	r3, [r4, #16]
}
 80012c0:	6958      	ldr	r0, [r3, #20]
 80012c2:	b006      	add	sp, #24
 80012c4:	bd70      	pop	{r4, r5, r6, pc}
 80012c6:	bf00      	nop
 80012c8:	20000904 	.word	0x20000904
 80012cc:	08001061 	.word	0x08001061

080012d0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 80012d0:	b169      	cbz	r1, 80012ee <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80012d2:	4b08      	ldr	r3, [pc, #32]	; (80012f4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80012d4:	b410      	push	{r4}
 80012d6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 80012d8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80012da:	691b      	ldr	r3, [r3, #16]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80012dc:	2004      	movs	r0, #4
 80012de:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 80012e2:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 80012e4:	6053      	str	r3, [r2, #4]
}
 80012e6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80012ea:	f7ff bfb1 	b.w	8001250 <chSchGoSleepTimeoutS>
}
 80012ee:	f04f 30ff 	mov.w	r0, #4294967295
 80012f2:	4770      	bx	lr
 80012f4:	20000904 	.word	0x20000904
	...

08001300 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8001300:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001304:	4698      	mov	r8, r3
 8001306:	4604      	mov	r4, r0
 8001308:	460d      	mov	r5, r1
 800130a:	4616      	mov	r6, r2
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800130c:	f8d0 901c 	ldr.w	r9, [r0, #28]
 8001310:	2320      	movs	r3, #32
 8001312:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
 8001316:	f8df b08c 	ldr.w	fp, [pc, #140]	; 80013a4 <oqWriteTimeout+0xa4>
 800131a:	f8db 3020 	ldr.w	r3, [fp, #32]
  size_t w = 0;
 800131e:	2700      	movs	r7, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8001320:	eb08 0a03 	add.w	sl, r8, r3

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8001324:	68a3      	ldr	r3, [r4, #8]
 8001326:	b303      	cbz	r3, 800136a <oqWriteTimeout+0x6a>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001328:	6962      	ldr	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800132a:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800132c:	1c51      	adds	r1, r2, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800132e:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8001330:	6161      	str	r1, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8001332:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001334:	782b      	ldrb	r3, [r5, #0]
 8001336:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001338:	6923      	ldr	r3, [r4, #16]
 800133a:	6962      	ldr	r2, [r4, #20]
 800133c:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800133e:	bf24      	itt	cs
 8001340:	68e3      	ldrcs	r3, [r4, #12]
 8001342:	6163      	strcs	r3, [r4, #20]
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001344:	3501      	adds	r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8001346:	f1b9 0f00 	cmp.w	r9, #0
 800134a:	d001      	beq.n	8001350 <oqWriteTimeout+0x50>
      nfy(oqp);
 800134c:	4620      	mov	r0, r4
 800134e:	47c8      	blx	r9
 8001350:	2300      	movs	r3, #0
 8001352:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 8001356:	3e01      	subs	r6, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 8001358:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 800135c:	d017      	beq.n	800138e <oqWriteTimeout+0x8e>
 800135e:	2320      	movs	r3, #32
 8001360:	f383 8811 	msr	BASEPRI, r3
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8001364:	68a3      	ldr	r3, [r4, #8]
 8001366:	2b00      	cmp	r3, #0
 8001368:	d1de      	bne.n	8001328 <oqWriteTimeout+0x28>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800136a:	f108 32ff 	add.w	r2, r8, #4294967295
 800136e:	3203      	adds	r2, #3
 8001370:	d810      	bhi.n	8001394 <oqWriteTimeout+0x94>
 8001372:	f8db 1020 	ldr.w	r1, [fp, #32]
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8001376:	ebc1 010a 	rsb	r1, r1, sl

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800137a:	4588      	cmp	r8, r1
 800137c:	d305      	bcc.n	800138a <oqWriteTimeout+0x8a>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 800137e:	4620      	mov	r0, r4
 8001380:	f7ff ffa6 	bl	80012d0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8001384:	2800      	cmp	r0, #0
 8001386:	d0cd      	beq.n	8001324 <oqWriteTimeout+0x24>
 8001388:	2300      	movs	r3, #0
 800138a:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 800138e:	4638      	mov	r0, r7
 8001390:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001394:	4641      	mov	r1, r8
 8001396:	4620      	mov	r0, r4
 8001398:	f7ff ff9a 	bl	80012d0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800139c:	2800      	cmp	r0, #0
 800139e:	d0c1      	beq.n	8001324 <oqWriteTimeout+0x24>
 80013a0:	e7f2      	b.n	8001388 <oqWriteTimeout+0x88>
 80013a2:	bf00      	nop
 80013a4:	20000904 	.word	0x20000904
	...

080013b0 <writet.lto_priv.49>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80013b0:	3030      	adds	r0, #48	; 0x30
 80013b2:	f7ff bfa5 	b.w	8001300 <oqWriteTimeout>
 80013b6:	bf00      	nop
	...

080013c0 <write.lto_priv.43>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80013c0:	3030      	adds	r0, #48	; 0x30
 80013c2:	f04f 33ff 	mov.w	r3, #4294967295
 80013c6:	f7ff bf9b 	b.w	8001300 <oqWriteTimeout>
 80013ca:	bf00      	nop
 80013cc:	0000      	movs	r0, r0
	...

080013d0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80013d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80013d2:	4604      	mov	r4, r0
 80013d4:	460f      	mov	r7, r1
 80013d6:	4616      	mov	r6, r2
 80013d8:	2320      	movs	r3, #32
 80013da:	f383 8811 	msr	BASEPRI, r3
 80013de:	e003      	b.n	80013e8 <oqPutTimeout+0x18>
 80013e0:	f7ff ff76 	bl	80012d0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 80013e4:	2800      	cmp	r0, #0
 80013e6:	db19      	blt.n	800141c <oqPutTimeout+0x4c>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 80013e8:	68a5      	ldr	r5, [r4, #8]
 80013ea:	4631      	mov	r1, r6
 80013ec:	4620      	mov	r0, r4
 80013ee:	2d00      	cmp	r5, #0
 80013f0:	d0f6      	beq.n	80013e0 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80013f2:	6962      	ldr	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80013f4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80013f6:	1c51      	adds	r1, r2, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80013f8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 80013fa:	6161      	str	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80013fc:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80013fe:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001400:	6923      	ldr	r3, [r4, #16]
 8001402:	6962      	ldr	r2, [r4, #20]
 8001404:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8001406:	bf24      	itt	cs
 8001408:	68e3      	ldrcs	r3, [r4, #12]
 800140a:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 800140c:	69e3      	ldr	r3, [r4, #28]
 800140e:	b10b      	cbz	r3, 8001414 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 8001410:	4620      	mov	r0, r4
 8001412:	4798      	blx	r3
 8001414:	2000      	movs	r0, #0
 8001416:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 800141a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800141c:	f385 8811 	msr	BASEPRI, r5
 8001420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001422:	bf00      	nop
	...

08001430 <putt.lto_priv.47>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001430:	3030      	adds	r0, #48	; 0x30
 8001432:	f7ff bfcd 	b.w	80013d0 <oqPutTimeout>
 8001436:	bf00      	nop
	...

08001440 <put.lto_priv.45>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001440:	3030      	adds	r0, #48	; 0x30
 8001442:	f04f 32ff 	mov.w	r2, #4294967295
 8001446:	f7ff bfc3 	b.w	80013d0 <oqPutTimeout>
 800144a:	bf00      	nop
 800144c:	0000      	movs	r0, r0
	...

08001450 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8001450:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001454:	4698      	mov	r8, r3
 8001456:	4604      	mov	r4, r0
 8001458:	460d      	mov	r5, r1
 800145a:	4616      	mov	r6, r2
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 800145c:	f8d0 901c 	ldr.w	r9, [r0, #28]
 8001460:	2320      	movs	r3, #32
 8001462:	f383 8811 	msr	BASEPRI, r3
 8001466:	f8df b08c 	ldr.w	fp, [pc, #140]	; 80014f4 <iqReadTimeout+0xa4>
 800146a:	f8db 3020 	ldr.w	r3, [fp, #32]
  size_t r = 0;
 800146e:	2700      	movs	r7, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8001470:	eb08 0a03 	add.w	sl, r8, r3

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8001474:	68a3      	ldr	r3, [r4, #8]
 8001476:	b303      	cbz	r3, 80014ba <iqReadTimeout+0x6a>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001478:	69a2      	ldr	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800147a:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800147c:	1c51      	adds	r1, r2, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800147e:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8001480:	61a1      	str	r1, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8001482:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001484:	7813      	ldrb	r3, [r2, #0]
 8001486:	702b      	strb	r3, [r5, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001488:	6923      	ldr	r3, [r4, #16]
 800148a:	69a2      	ldr	r2, [r4, #24]
 800148c:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 800148e:	bf24      	itt	cs
 8001490:	68e3      	ldrcs	r3, [r4, #12]
 8001492:	61a3      	strcs	r3, [r4, #24]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001494:	3501      	adds	r5, #1
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8001496:	f1b9 0f00 	cmp.w	r9, #0
 800149a:	d001      	beq.n	80014a0 <iqReadTimeout+0x50>
      nfy(iqp);
 800149c:	4620      	mov	r0, r4
 800149e:	47c8      	blx	r9
 80014a0:	2300      	movs	r3, #0
 80014a2:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 80014a6:	3e01      	subs	r6, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 80014a8:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 80014ac:	d017      	beq.n	80014de <iqReadTimeout+0x8e>
 80014ae:	2320      	movs	r3, #32
 80014b0:	f383 8811 	msr	BASEPRI, r3
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 80014b4:	68a3      	ldr	r3, [r4, #8]
 80014b6:	2b00      	cmp	r3, #0
 80014b8:	d1de      	bne.n	8001478 <iqReadTimeout+0x28>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80014ba:	f108 32ff 	add.w	r2, r8, #4294967295
 80014be:	3203      	adds	r2, #3
 80014c0:	d810      	bhi.n	80014e4 <iqReadTimeout+0x94>
 80014c2:	f8db 1020 	ldr.w	r1, [fp, #32]
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80014c6:	ebc1 010a 	rsb	r1, r1, sl

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80014ca:	4588      	cmp	r8, r1
 80014cc:	d305      	bcc.n	80014da <iqReadTimeout+0x8a>
 80014ce:	4620      	mov	r0, r4
 80014d0:	f7ff fefe 	bl	80012d0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80014d4:	2800      	cmp	r0, #0
 80014d6:	d0cd      	beq.n	8001474 <iqReadTimeout+0x24>
 80014d8:	2300      	movs	r3, #0
 80014da:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 80014de:	4638      	mov	r0, r7
 80014e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80014e4:	4641      	mov	r1, r8
 80014e6:	4620      	mov	r0, r4
 80014e8:	f7ff fef2 	bl	80012d0 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80014ec:	2800      	cmp	r0, #0
 80014ee:	d0c1      	beq.n	8001474 <iqReadTimeout+0x24>
 80014f0:	e7f2      	b.n	80014d8 <iqReadTimeout+0x88>
 80014f2:	bf00      	nop
 80014f4:	20000904 	.word	0x20000904
	...

08001500 <readt.lto_priv.50>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001500:	300c      	adds	r0, #12
 8001502:	f7ff bfa5 	b.w	8001450 <iqReadTimeout>
 8001506:	bf00      	nop
	...

08001510 <read.lto_priv.44>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001510:	300c      	adds	r0, #12
 8001512:	f04f 33ff 	mov.w	r3, #4294967295
 8001516:	f7ff bf9b 	b.w	8001450 <iqReadTimeout>
 800151a:	bf00      	nop
 800151c:	0000      	movs	r0, r0
	...

08001520 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001520:	b570      	push	{r4, r5, r6, lr}
 8001522:	2320      	movs	r3, #32
 8001524:	4604      	mov	r4, r0
 8001526:	460e      	mov	r6, r1
 8001528:	f383 8811 	msr	BASEPRI, r3
 800152c:	e003      	b.n	8001536 <iqGetTimeout+0x16>
 800152e:	f7ff fecf 	bl	80012d0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8001532:	2800      	cmp	r0, #0
 8001534:	db1a      	blt.n	800156c <iqGetTimeout+0x4c>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8001536:	68a5      	ldr	r5, [r4, #8]
 8001538:	4631      	mov	r1, r6
 800153a:	4620      	mov	r0, r4
 800153c:	2d00      	cmp	r5, #0
 800153e:	d0f6      	beq.n	800152e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001540:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8001542:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001544:	6920      	ldr	r0, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001546:	1c4a      	adds	r2, r1, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8001548:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800154a:	4282      	cmp	r2, r0
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800154c:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800154e:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001550:	bf28      	it	cs
 8001552:	68e3      	ldrcs	r3, [r4, #12]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001554:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001556:	bf28      	it	cs
 8001558:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800155a:	69e3      	ldr	r3, [r4, #28]
 800155c:	b10b      	cbz	r3, 8001562 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 800155e:	4620      	mov	r0, r4
 8001560:	4798      	blx	r3
 8001562:	2300      	movs	r3, #0
 8001564:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 8001568:	4628      	mov	r0, r5
}
 800156a:	bd70      	pop	{r4, r5, r6, pc}
 800156c:	f385 8811 	msr	BASEPRI, r5
 8001570:	bd70      	pop	{r4, r5, r6, pc}
 8001572:	bf00      	nop
	...

08001580 <gett.lto_priv.48>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001580:	300c      	adds	r0, #12
 8001582:	f7ff bfcd 	b.w	8001520 <iqGetTimeout>
 8001586:	bf00      	nop
	...

08001590 <get.lto_priv.46>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001590:	300c      	adds	r0, #12
 8001592:	f04f 31ff 	mov.w	r1, #4294967295
 8001596:	f7ff bfc3 	b.w	8001520 <iqGetTimeout>
 800159a:	bf00      	nop
 800159c:	0000      	movs	r0, r0
	...

080015a0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80015a0:	2200      	movs	r2, #0
 80015a2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80015a4:	4b08      	ldr	r3, [pc, #32]	; (80015c8 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80015a6:	b410      	push	{r4}
 80015a8:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80015aa:	7402      	strb	r2, [r0, #16]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 80015ac:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80015ae:	689a      	ldr	r2, [r3, #8]
 80015b0:	428a      	cmp	r2, r1
 80015b2:	d2fb      	bcs.n	80015ac <chSchReadyI+0xc>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80015b4:	685a      	ldr	r2, [r3, #4]
 80015b6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80015b8:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 80015ba:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80015bc:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80015be:	605c      	str	r4, [r3, #4]

  return tp;
}
 80015c0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80015c4:	4770      	bx	lr
 80015c6:	bf00      	nop
 80015c8:	20000904 	.word	0x20000904
 80015cc:	00000000 	.word	0x00000000

080015d0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80015d0:	b538      	push	{r3, r4, r5, lr}
 80015d2:	2220      	movs	r2, #32
 80015d4:	4603      	mov	r3, r0
 80015d6:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80015da:	4a0a      	ldr	r2, [pc, #40]	; (8001604 <chThdExit+0x34>)
 80015dc:	6914      	ldr	r4, [r2, #16]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80015de:	69a0      	ldr	r0, [r4, #24]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80015e0:	6163      	str	r3, [r4, #20]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80015e2:	f104 0518 	add.w	r5, r4, #24
 80015e6:	42a8      	cmp	r0, r5
 80015e8:	d006      	beq.n	80015f8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80015ea:	6803      	ldr	r3, [r0, #0]
 80015ec:	61a3      	str	r3, [r4, #24]
    (void) chSchReadyI(list_remove(&tp->waiting));
 80015ee:	f7ff ffd7 	bl	80015a0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80015f2:	69a0      	ldr	r0, [r4, #24]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80015f4:	42a8      	cmp	r0, r5
 80015f6:	d1f8      	bne.n	80015ea <chThdExit+0x1a>
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80015f8:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 80015fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80015fe:	f7ff bd77 	b.w	80010f0 <chSchGoSleepS>
 8001602:	bf00      	nop
 8001604:	20000904 	.word	0x20000904
	...

08001610 <_port_irq_epilogue>:
 8001610:	2320      	movs	r3, #32
 8001612:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001616:	4b12      	ldr	r3, [pc, #72]	; (8001660 <_port_irq_epilogue+0x50>)
 8001618:	685b      	ldr	r3, [r3, #4]
 800161a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800161e:	d102      	bne.n	8001626 <_port_irq_epilogue+0x16>
 8001620:	f383 8811 	msr	BASEPRI, r3
 8001624:	4770      	bx	lr
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8001626:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800162a:	f3ef 8309 	mrs	r3, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800162e:	4a0d      	ldr	r2, [pc, #52]	; (8001664 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001630:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8001634:	68d2      	ldr	r2, [r2, #12]
 8001636:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800163a:	f843 1c4c 	str.w	r1, [r3, #-76]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800163e:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
 8001642:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001646:	4a08      	ldr	r2, [pc, #32]	; (8001668 <_port_irq_epilogue+0x58>)
 8001648:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800164a:	6912      	ldr	r2, [r2, #16]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800164c:	6889      	ldr	r1, [r1, #8]
 800164e:	6892      	ldr	r2, [r2, #8]
 8001650:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001652:	bf8c      	ite	hi
 8001654:	4a05      	ldrhi	r2, [pc, #20]	; (800166c <_port_irq_epilogue+0x5c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001656:	4a06      	ldrls	r2, [pc, #24]	; (8001670 <_port_irq_epilogue+0x60>)
 8001658:	f843 2c50 	str.w	r2, [r3, #-80]
 800165c:	4770      	bx	lr
 800165e:	bf00      	nop
 8001660:	e000ed00 	.word	0xe000ed00
 8001664:	e000ef30 	.word	0xe000ef30
 8001668:	20000904 	.word	0x20000904
 800166c:	080001c9 	.word	0x080001c9
 8001670:	080001cc 	.word	0x080001cc
	...

08001680 <VectorDC>:
/**
 * @brief   USART3 IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8001680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 *
 * @param[in] uartp     pointer to the @p UARTDriver object
 */
static void serve_usart_irq(UARTDriver *uartp) {
  uint32_t isr;
  USART_TypeDef *u = uartp->usart;
 8001682:	4e19      	ldr	r6, [pc, #100]	; (80016e8 <VectorDC+0x68>)
 8001684:	68b5      	ldr	r5, [r6, #8]
  uint32_t cr1 = u->CR1;
 8001686:	682f      	ldr	r7, [r5, #0]
  
  /* Reading and clearing status.*/
  isr = u->ISR;
 8001688:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 800168a:	622c      	str	r4, [r5, #32]

  if (isr & (USART_ISR_LBDF | USART_ISR_ORE | USART_ISR_NE |
 800168c:	f240 130f 	movw	r3, #271	; 0x10f
 8001690:	4023      	ands	r3, r4
 8001692:	b1cb      	cbz	r3, 80016c8 <VectorDC+0x48>
             USART_ISR_FE   | USART_ISR_PE)) {
    _uart_rx_error_isr_code(uartp, translate_errors(isr));
 8001694:	6873      	ldr	r3, [r6, #4]
 8001696:	691b      	ldr	r3, [r3, #16]
 8001698:	b1b3      	cbz	r3, 80016c8 <VectorDC+0x48>
 */
static uartflags_t translate_errors(uint32_t isr) {
  uartflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= UART_OVERRUN_ERROR;
 800169a:	f014 0f08 	tst.w	r4, #8
 800169e:	bf0c      	ite	eq
 80016a0:	2100      	moveq	r1, #0
 80016a2:	2110      	movne	r1, #16
  if (isr & USART_ISR_PE)
 80016a4:	07e2      	lsls	r2, r4, #31
    sts |= UART_PARITY_ERROR;
 80016a6:	bf48      	it	mi
 80016a8:	f041 0104 	orrmi.w	r1, r1, #4
  if (isr & USART_ISR_FE)
 80016ac:	07a0      	lsls	r0, r4, #30
    sts |= UART_FRAMING_ERROR;
 80016ae:	bf48      	it	mi
 80016b0:	f041 0108 	orrmi.w	r1, r1, #8
  if (isr & USART_ISR_NE)
 80016b4:	0762      	lsls	r2, r4, #29
    sts |= UART_NOISE_ERROR;
 80016b6:	bf48      	it	mi
 80016b8:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_LBDF)
 80016bc:	05e0      	lsls	r0, r4, #23
    sts |= UART_BREAK_DETECTED;
 80016be:	bf48      	it	mi
 80016c0:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  isr = u->ISR;
  u->ICR = isr;

  if (isr & (USART_ISR_LBDF | USART_ISR_ORE | USART_ISR_NE |
             USART_ISR_FE   | USART_ISR_PE)) {
    _uart_rx_error_isr_code(uartp, translate_errors(isr));
 80016c4:	4808      	ldr	r0, [pc, #32]	; (80016e8 <VectorDC+0x68>)
 80016c6:	4798      	blx	r3
  }

  if ((isr & USART_ISR_TC) && (cr1 & USART_CR1_TCIE)) {
 80016c8:	0662      	lsls	r2, r4, #25
 80016ca:	d509      	bpl.n	80016e0 <VectorDC+0x60>
 80016cc:	067b      	lsls	r3, r7, #25
 80016ce:	d507      	bpl.n	80016e0 <VectorDC+0x60>
    /* TC interrupt disabled.*/
    u->CR1 = cr1 & ~USART_CR1_TCIE;

    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
 80016d0:	6873      	ldr	r3, [r6, #4]
 80016d2:	685b      	ldr	r3, [r3, #4]
    _uart_rx_error_isr_code(uartp, translate_errors(isr));
  }

  if ((isr & USART_ISR_TC) && (cr1 & USART_CR1_TCIE)) {
    /* TC interrupt disabled.*/
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80016d4:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 80016d8:	602f      	str	r7, [r5, #0]

    /* End of transmission, a callback is generated.*/
    _uart_tx2_isr_code(uartp);
 80016da:	b10b      	cbz	r3, 80016e0 <VectorDC+0x60>
 80016dc:	4802      	ldr	r0, [pc, #8]	; (80016e8 <VectorDC+0x68>)
 80016de:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);

  OSAL_IRQ_EPILOGUE();
}
 80016e0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_usart_irq(&UARTD3);

  OSAL_IRQ_EPILOGUE();
 80016e4:	f7ff bf94 	b.w	8001610 <_port_irq_epilogue>
 80016e8:	20000d28 	.word	0x20000d28
 80016ec:	00000000 	.word	0x00000000

080016f0 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 80016f0:	b570      	push	{r4, r5, r6, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80016f2:	2320      	movs	r3, #32
 80016f4:	f383 8811 	msr	BASEPRI, r3
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 80016f8:	4c12      	ldr	r4, [pc, #72]	; (8001744 <SysTick_Handler+0x54>)
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 80016fa:	4626      	mov	r6, r4
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 80016fc:	6a22      	ldr	r2, [r4, #32]
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 80016fe:	f856 3f14 	ldr.w	r3, [r6, #20]!
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 8001702:	3201      	adds	r2, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 8001704:	42b3      	cmp	r3, r6
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
 8001706:	6222      	str	r2, [r4, #32]
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
 8001708:	d014      	beq.n	8001734 <SysTick_Handler+0x44>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
 800170a:	689a      	ldr	r2, [r3, #8]
 800170c:	3a01      	subs	r2, #1
 800170e:	609a      	str	r2, [r3, #8]
    while (ch.vtlist.next->delta == (systime_t)0) {
 8001710:	b982      	cbnz	r2, 8001734 <SysTick_Handler+0x44>
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
      vtp->func = NULL;
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001712:	6819      	ldr	r1, [r3, #0]
    while (ch.vtlist.next->delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
 8001714:	68dd      	ldr	r5, [r3, #12]
      vtp->func = NULL;
 8001716:	2200      	movs	r2, #0
 8001718:	60da      	str	r2, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800171a:	604e      	str	r6, [r1, #4]
      ch.vtlist.next = vtp->next;
 800171c:	6161      	str	r1, [r4, #20]
 800171e:	f382 8811 	msr	BASEPRI, r2
      chSysUnlockFromISR();
      fn(vtp->par);
 8001722:	6918      	ldr	r0, [r3, #16]
 8001724:	47a8      	blx	r5
 8001726:	2320      	movs	r3, #32
 8001728:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
    while (ch.vtlist.next->delta == (systime_t)0) {
 800172c:	6963      	ldr	r3, [r4, #20]
 800172e:	689a      	ldr	r2, [r3, #8]
 8001730:	2a00      	cmp	r2, #0
 8001732:	d0ee      	beq.n	8001712 <SysTick_Handler+0x22>
 8001734:	2300      	movs	r3, #0
 8001736:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 800173a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800173e:	f7ff bf67 	b.w	8001610 <_port_irq_epilogue>
 8001742:	bf00      	nop
 8001744:	20000904 	.word	0x20000904
	...

08001750 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001750:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001754:	4d61      	ldr	r5, [pc, #388]	; (80018dc <VectorD8+0x18c>)
 8001756:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 8001758:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800175a:	69f4      	ldr	r4, [r6, #28]
  u->ICR = isr;
 800175c:	6234      	str	r4, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800175e:	0722      	lsls	r2, r4, #28
 8001760:	d153      	bne.n	800180a <VectorD8+0xba>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8001762:	05e3      	lsls	r3, r4, #23
 8001764:	d446      	bmi.n	80017f4 <VectorD8+0xa4>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8001766:	06a0      	lsls	r0, r4, #26
 8001768:	d418      	bmi.n	800179c <VectorD8+0x4c>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800176a:	0639      	lsls	r1, r7, #24
 800176c:	d501      	bpl.n	8001772 <VectorD8+0x22>
 800176e:	0622      	lsls	r2, r4, #24
 8001770:	d465      	bmi.n	800183e <VectorD8+0xee>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8001772:	0663      	lsls	r3, r4, #25
 8001774:	d50e      	bpl.n	8001794 <VectorD8+0x44>
 8001776:	2320      	movs	r3, #32
 8001778:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 800177c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800177e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8001780:	4956      	ldr	r1, [pc, #344]	; (80018dc <VectorD8+0x18c>)
 8001782:	429a      	cmp	r2, r3
 8001784:	f000 8089 	beq.w	800189a <VectorD8+0x14a>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001788:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 800178c:	6037      	str	r7, [r6, #0]
 800178e:	2300      	movs	r3, #0
 8001790:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 8001794:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8001798:	f7ff bf3a 	b.w	8001610 <_port_irq_epilogue>
 800179c:	2320      	movs	r3, #32
 800179e:	f383 8811 	msr	BASEPRI, r3
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 80017a2:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80017a4:	696b      	ldr	r3, [r5, #20]
 80017a6:	fa5f f882 	uxtb.w	r8, r2
 80017aa:	2b00      	cmp	r3, #0
 80017ac:	d07d      	beq.n	80018aa <VectorD8+0x15a>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 80017ae:	6a2b      	ldr	r3, [r5, #32]
 80017b0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80017b2:	494a      	ldr	r1, [pc, #296]	; (80018dc <VectorD8+0x18c>)
 80017b4:	4293      	cmp	r3, r2
 80017b6:	d07c      	beq.n	80018b2 <VectorD8+0x162>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 80017b8:	696a      	ldr	r2, [r5, #20]
 80017ba:	4948      	ldr	r1, [pc, #288]	; (80018dc <VectorD8+0x18c>)
 80017bc:	3201      	adds	r2, #1
 80017be:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 80017c0:	1c5a      	adds	r2, r3, #1
 80017c2:	622a      	str	r2, [r5, #32]
 80017c4:	f883 8000 	strb.w	r8, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
 80017c8:	6a2a      	ldr	r2, [r5, #32]
 80017ca:	69eb      	ldr	r3, [r5, #28]
 80017cc:	429a      	cmp	r2, r3
 80017ce:	d261      	bcs.n	8001894 <VectorD8+0x144>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80017d0:	4942      	ldr	r1, [pc, #264]	; (80018dc <VectorD8+0x18c>)
 80017d2:	68eb      	ldr	r3, [r5, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80017d4:	f101 020c 	add.w	r2, r1, #12
 80017d8:	4293      	cmp	r3, r2
 80017da:	d007      	beq.n	80017ec <VectorD8+0x9c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80017dc:	6818      	ldr	r0, [r3, #0]
 80017de:	60c8      	str	r0, [r1, #12]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80017e0:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80017e2:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 80017e4:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80017e6:	6159      	str	r1, [r3, #20]
  (void) chSchReadyI(tp);
 80017e8:	f7ff feda 	bl	80015a0 <chSchReadyI>
 80017ec:	2300      	movs	r3, #0
 80017ee:	f383 8811 	msr	BASEPRI, r3
 80017f2:	e7ba      	b.n	800176a <VectorD8+0x1a>
 80017f4:	2320      	movs	r3, #32
 80017f6:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80017fa:	f44f 7000 	mov.w	r0, #512	; 0x200
 80017fe:	f7ff f80f 	bl	8000820 <chEvtBroadcastFlagsI.constprop.35>
 8001802:	2300      	movs	r3, #0
 8001804:	f383 8811 	msr	BASEPRI, r3
 8001808:	e7ad      	b.n	8001766 <VectorD8+0x16>
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
 800180a:	f014 0f08 	tst.w	r4, #8
 800180e:	bf0c      	ite	eq
 8001810:	2000      	moveq	r0, #0
 8001812:	2080      	movne	r0, #128	; 0x80
  if (isr & USART_ISR_PE)
 8001814:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 8001816:	bf48      	it	mi
 8001818:	f040 0020 	orrmi.w	r0, r0, #32
  if (isr & USART_ISR_FE)
 800181c:	07a1      	lsls	r1, r4, #30
    sts |= SD_FRAMING_ERROR;
 800181e:	bf48      	it	mi
 8001820:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (isr & USART_ISR_NE)
 8001824:	0762      	lsls	r2, r4, #29
    sts |= SD_NOISE_ERROR;
 8001826:	bf48      	it	mi
 8001828:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 800182c:	2320      	movs	r3, #32
 800182e:	f383 8811 	msr	BASEPRI, r3
 8001832:	f7fe fff5 	bl	8000820 <chEvtBroadcastFlagsI.constprop.35>
 8001836:	2300      	movs	r3, #0
 8001838:	f383 8811 	msr	BASEPRI, r3
 800183c:	e791      	b.n	8001762 <VectorD8+0x12>
 800183e:	2320      	movs	r3, #32
 8001840:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8001844:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8001846:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8001848:	4924      	ldr	r1, [pc, #144]	; (80018dc <VectorD8+0x18c>)
 800184a:	429a      	cmp	r2, r3
 800184c:	d039      	beq.n	80018c2 <VectorD8+0x172>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 800184e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8001850:	4922      	ldr	r1, [pc, #136]	; (80018dc <VectorD8+0x18c>)
  b = *oqp->q_rdptr++;
 8001852:	1c58      	adds	r0, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8001854:	3201      	adds	r2, #1
 8001856:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8001858:	64a8      	str	r0, [r5, #72]	; 0x48
 800185a:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 800185e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8001860:	4298      	cmp	r0, r3
 8001862:	d301      	bcc.n	8001868 <VectorD8+0x118>
    oqp->q_rdptr = oqp->q_buffer;
 8001864:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8001866:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001868:	491c      	ldr	r1, [pc, #112]	; (80018dc <VectorD8+0x18c>)
 800186a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800186c:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8001870:	4293      	cmp	r3, r2
 8001872:	d007      	beq.n	8001884 <VectorD8+0x134>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001874:	6818      	ldr	r0, [r3, #0]
 8001876:	6308      	str	r0, [r1, #48]	; 0x30

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8001878:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 800187a:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 800187c:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800187e:	6159      	str	r1, [r3, #20]
  (void) chSchReadyI(tp);
 8001880:	f7ff fe8e 	bl	80015a0 <chSchReadyI>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8001884:	fa1f f888 	uxth.w	r8, r8
 8001888:	f8a6 8028 	strh.w	r8, [r6, #40]	; 0x28
 800188c:	2300      	movs	r3, #0
 800188e:	f383 8811 	msr	BASEPRI, r3
 8001892:	e76e      	b.n	8001772 <VectorD8+0x22>
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 8001894:	698b      	ldr	r3, [r1, #24]
 8001896:	620b      	str	r3, [r1, #32]
 8001898:	e79a      	b.n	80017d0 <VectorD8+0x80>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 800189a:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 800189c:	2b00      	cmp	r3, #0
 800189e:	f43f af73 	beq.w	8001788 <VectorD8+0x38>
 80018a2:	2010      	movs	r0, #16
 80018a4:	f7fe ffbc 	bl	8000820 <chEvtBroadcastFlagsI.constprop.35>
 80018a8:	e76e      	b.n	8001788 <VectorD8+0x38>
 80018aa:	2004      	movs	r0, #4
 80018ac:	f7fe ffb8 	bl	8000820 <chEvtBroadcastFlagsI.constprop.35>
 80018b0:	e77d      	b.n	80017ae <VectorD8+0x5e>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 80018b2:	694a      	ldr	r2, [r1, #20]
 80018b4:	2a00      	cmp	r2, #0
 80018b6:	f43f af7f 	beq.w	80017b8 <VectorD8+0x68>
 80018ba:	2080      	movs	r0, #128	; 0x80
 80018bc:	f7fe ffb0 	bl	8000820 <chEvtBroadcastFlagsI.constprop.35>
 80018c0:	e794      	b.n	80017ec <VectorD8+0x9c>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80018c2:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 80018c4:	2a00      	cmp	r2, #0
 80018c6:	d0c2      	beq.n	800184e <VectorD8+0xfe>
 80018c8:	2008      	movs	r0, #8
 80018ca:	f7fe ffa9 	bl	8000820 <chEvtBroadcastFlagsI.constprop.35>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80018ce:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
 80018d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80018d6:	6033      	str	r3, [r6, #0]
 80018d8:	e7d8      	b.n	800188c <VectorD8+0x13c>
 80018da:	bf00      	nop
 80018dc:	20000888 	.word	0x20000888

080018e0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80018e0:	4a23      	ldr	r2, [pc, #140]	; (8001970 <__early_init+0x90>)
 80018e2:	6813      	ldr	r3, [r2, #0]
 80018e4:	f043 0301 	orr.w	r3, r3, #1
 80018e8:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80018ea:	4b21      	ldr	r3, [pc, #132]	; (8001970 <__early_init+0x90>)
 80018ec:	681a      	ldr	r2, [r3, #0]
 80018ee:	0792      	lsls	r2, r2, #30
 80018f0:	d5fb      	bpl.n	80018ea <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80018f2:	685a      	ldr	r2, [r3, #4]
 80018f4:	f022 0203 	bic.w	r2, r2, #3
 80018f8:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80018fa:	685a      	ldr	r2, [r3, #4]
 80018fc:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80018fe:	4a1c      	ldr	r2, [pc, #112]	; (8001970 <__early_init+0x90>)
 8001900:	6853      	ldr	r3, [r2, #4]
 8001902:	f013 030c 	ands.w	r3, r3, #12
 8001906:	d1fa      	bne.n	80018fe <__early_init+0x1e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001908:	6811      	ldr	r1, [r2, #0]
 800190a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800190e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001910:	6053      	str	r3, [r2, #4]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001912:	6813      	ldr	r3, [r2, #0]
 8001914:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001918:	6013      	str	r3, [r2, #0]
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 800191a:	4b15      	ldr	r3, [pc, #84]	; (8001970 <__early_init+0x90>)
 800191c:	681a      	ldr	r2, [r3, #0]
 800191e:	0390      	lsls	r0, r2, #14
 8001920:	d5fb      	bpl.n	800191a <__early_init+0x3a>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001922:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001924:	f042 0201 	orr.w	r2, r2, #1
 8001928:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800192a:	4b11      	ldr	r3, [pc, #68]	; (8001970 <__early_init+0x90>)
 800192c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800192e:	0791      	lsls	r1, r2, #30
 8001930:	d5fb      	bpl.n	800192a <__early_init+0x4a>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8001932:	4a10      	ldr	r2, [pc, #64]	; (8001974 <__early_init+0x94>)
 8001934:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001936:	f242 1101 	movw	r1, #8449	; 0x2101
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 800193a:	2230      	movs	r2, #48	; 0x30

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 800193c:	62d9      	str	r1, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 800193e:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001940:	681a      	ldr	r2, [r3, #0]
 8001942:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001946:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001948:	4b09      	ldr	r3, [pc, #36]	; (8001970 <__early_init+0x90>)
 800194a:	681a      	ldr	r2, [r3, #0]
 800194c:	0192      	lsls	r2, r2, #6
 800194e:	d5fb      	bpl.n	8001948 <__early_init+0x68>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001950:	4a09      	ldr	r2, [pc, #36]	; (8001978 <__early_init+0x98>)
 8001952:	2112      	movs	r1, #18
 8001954:	6011      	str	r1, [r2, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001956:	685a      	ldr	r2, [r3, #4]
 8001958:	f042 0202 	orr.w	r2, r2, #2
 800195c:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800195e:	4a04      	ldr	r2, [pc, #16]	; (8001970 <__early_init+0x90>)
 8001960:	6853      	ldr	r3, [r2, #4]
 8001962:	f003 030c 	and.w	r3, r3, #12
 8001966:	2b08      	cmp	r3, #8
 8001968:	d1f9      	bne.n	800195e <__early_init+0x7e>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 800196a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800196c:	6313      	str	r3, [r2, #48]	; 0x30
 800196e:	4770      	bx	lr
 8001970:	40021000 	.word	0x40021000
 8001974:	001d2d00 	.word	0x001d2d00
 8001978:	40022000 	.word	0x40022000
